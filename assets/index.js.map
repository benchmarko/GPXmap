{"version":3,"file":"index.js","sources":["../../node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js","../../src/LatLng.ts","../../src/ScriptParser.ts","../../src/ZipCrypto.ts","../../src/ZipFile.ts","../../src/main.ts"],"sourcesContent":["/*\n * Leaflet.markercluster 1.5.3+master.e5124b2,\n * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n * https://github.com/Leaflet/Leaflet.markercluster\n * (c) 2012-2017, Dave Leaver, smartrak\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory((global.Leaflet = global.Leaflet || {}, global.Leaflet.markercluster = {})));\n}(this, function (exports) { 'use strict';\n\n\t/*\n\t * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n\t */\n\n\tvar MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({\n\n\t\toptions: {\n\t\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\n\t\t\ticonCreateFunction: null,\n\t\t\tclusterPane: L.Marker.prototype.options.pane,\n\n\t\t\tspiderfyOnEveryZoom: false,\n\t\t\tspiderfyOnMaxZoom: true,\n\t\t\tshowCoverageOnHover: true,\n\t\t\tzoomToBoundsOnClick: true,\n\t\t\tsingleMarkerMode: false,\n\n\t\t\tdisableClusteringAtZoom: null,\n\n\t\t\t// Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n\t\t\t// is the default behaviour for performance reasons.\n\t\t\tremoveOutsideVisibleBounds: true,\n\n\t\t\t// Set to false to disable all animations (zoom and spiderfy).\n\t\t\t// If false, option animateAddingMarkers below has no effect.\n\t\t\t// If L.DomUtil.TRANSITION is falsy, this option has no effect.\n\t\t\tanimate: true,\n\n\t\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\n\t\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n\t\t\tanimateAddingMarkers: false,\n\n\t\t\t// Make it possible to provide custom function to calculate spiderfy shape positions\n\t\t\tspiderfyShapePositions: null,\n\n\t\t\t//Increase to increase the distance away that spiderfied markers appear from the center\n\t\t\tspiderfyDistanceMultiplier: 1,\n\n\t\t\t// Make it possible to specify a polyline options on a spider leg\n\t\t\tspiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },\n\n\t\t\t// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts\n\t\t\tchunkedLoading: false,\n\t\t\tchunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)\n\t\t\tchunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser\n\t\t\tchunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)\n\n\t\t\t//Options to pass to the L.Polygon constructor\n\t\t\tpolygonOptions: {}\n\t\t},\n\n\t\tinitialize: function (options) {\n\t\t\tL.Util.setOptions(this, options);\n\t\t\tif (!this.options.iconCreateFunction) {\n\t\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\n\t\t\t}\n\n\t\t\tthis._featureGroup = L.featureGroup();\n\t\t\tthis._featureGroup.addEventParent(this);\n\n\t\t\tthis._nonPointGroup = L.featureGroup();\n\t\t\tthis._nonPointGroup.addEventParent(this);\n\n\t\t\tthis._inZoomAnimation = 0;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\n\t\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n\t\t\tthis._currentShownBounds = null;\n\n\t\t\tthis._queue = [];\n\n\t\t\tthis._childMarkerEventHandlers = {\n\t\t\t\t'dragstart': this._childMarkerDragStart,\n\t\t\t\t'move': this._childMarkerMoved,\n\t\t\t\t'dragend': this._childMarkerDragEnd,\n\t\t\t};\n\n\t\t\t// Hook the appropriate animation methods.\n\t\t\tvar animate = L.DomUtil.TRANSITION && this.options.animate;\n\t\t\tL.extend(this, animate ? this._withAnimation : this._noAnimation);\n\t\t\t// Remember which MarkerCluster class to instantiate (animated or not).\n\t\t\tthis._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\n\t\t},\n\n\t\taddLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.addLayers([layer]);\n\t\t\t}\n\n\t\t\t//Don't cluster non point data\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.addLayer(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering.push(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\n\t\t\t//If we have already clustered we'll need to add this one to a cluster\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t}\n\n\t\t\tthis._addLayer(layer, this._maxZoom);\n\t\t\tthis.fire('layeradd', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Work out what is visible\n\t\t\tvar visibleLayer = layer,\n\t\t\t    currentZoom = this._zoom;\n\t\t\tif (layer.__parent) {\n\t\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\n\t\t\t\t\tvisibleLayer = visibleLayer.__parent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n\t\t\t\tif (this.options.animateAddingMarkers) {\n\t\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\n\t\t\t\t} else {\n\t\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.removeLayers([layer]);\n\t\t\t}\n\n\t\t\t//Non point layers\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.removeLayer(layer);\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tif (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\n\t\t\t\t\tthis._needsRemoving.push({ layer: layer, latlng: layer._latlng });\n\t\t\t\t}\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!layer.__parent) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t\tthis._unspiderfyLayer(layer);\n\t\t\t}\n\n\t\t\t//Remove the marker from clusters\n\t\t\tthis._removeLayer(layer, true);\n\t\t\tthis.fire('layerremove', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\tlayer.off(this._childMarkerEventHandlers, this);\n\n\t\t\tif (this._featureGroup.hasLayer(layer)) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and adds them in bulk\n\t\taddLayers: function (layersArray, skipLayerAddEvent) {\n\t\t\tif (!L.Util.isArray(layersArray)) {\n\t\t\t\treturn this.addLayer(layersArray);\n\t\t\t}\n\n\t\t\tvar fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    chunked = this.options.chunkedLoading,\n\t\t\t    chunkInterval = this.options.chunkInterval,\n\t\t\t    chunkProgress = this.options.chunkProgress,\n\t\t\t    l = layersArray.length,\n\t\t\t    offset = 0,\n\t\t\t    originalArray = true,\n\t\t\t    m;\n\n\t\t\tif (this._map) {\n\t\t\t\tvar started = (new Date()).getTime();\n\t\t\t\tvar process = L.bind(function () {\n\t\t\t\t\tvar start = (new Date()).getTime();\n\n\t\t\t\t\t// Make sure to unspiderfy before starting to add some layers\n\t\t\t\t\tif (this._map && this._unspiderfy) {\n\t\t\t\t\t\tthis._unspiderfy();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\t\tif (chunked && offset % 200 === 0) {\n\t\t\t\t\t\t\t// every couple hundred markers, instrument the time elapsed since processing started:\n\t\t\t\t\t\t\tvar elapsed = (new Date()).getTime() - start;\n\t\t\t\t\t\t\tif (elapsed > chunkInterval) {\n\t\t\t\t\t\t\t\tbreak; // been working too hard, time to take a break :-)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\t\t// Side effects:\n\t\t\t\t\t\t// - Total increases, so chunkProgress ratio jumps backward.\n\t\t\t\t\t\t// - Groups are not included in this group, only their non-group child layers (hasLayer).\n\t\t\t\t\t\t// Changing array length while looping does not affect performance in current browsers:\n\t\t\t\t\t\t// http://jsperf.com/for-loop-changing-length/6\n\t\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._addLayer(m, this._maxZoom);\n\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n\t\t\t\t\t\tif (m.__parent) {\n\t\t\t\t\t\t\tif (m.__parent.getChildCount() === 2) {\n\t\t\t\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\n\t\t\t\t\t\t\t\t    otherMarker = markers[0] === m ? markers[1] : markers[0];\n\t\t\t\t\t\t\t\tfg.removeLayer(otherMarker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunkProgress) {\n\t\t\t\t\t\t// report progress and time elapsed:\n\t\t\t\t\t\tchunkProgress(offset, l, (new Date()).getTime() - started);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Completed processing all markers.\n\t\t\t\t\tif (offset === l) {\n\n\t\t\t\t\t\t// Refresh bounds and weighted positions.\n\t\t\t\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\t\t\t\tthis._refreshClustersIcons();\n\n\t\t\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(process, this.options.chunkDelay);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\tprocess();\n\t\t\t} else {\n\t\t\t\tvar needsClustering = this._needsClustering;\n\n\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsClustering.push(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and removes them in bulk\n\t\tremoveLayers: function (layersArray) {\n\t\t\tvar i, m,\n\t\t\t    l = layersArray.length,\n\t\t\t    fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    originalArray = true;\n\n\t\t\tif (!this._map) {\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tm = layersArray[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._arraySplice(this._needsClustering, m);\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tthis._needsRemoving.push({ layer: m, latlng: m._latlng });\n\t\t\t\t\t}\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\n\t\t\t\t// Work on a copy of the array, so that next loop is not affected.\n\t\t\t\tvar layersArray2 = layersArray.slice(),\n\t\t\t\t    l2 = l;\n\t\t\t\tfor (i = 0; i < l2; i++) {\n\t\t\t\t\tm = layersArray2[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray2);\n\t\t\t\t\t\tl2 = layersArray2.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._unspiderfyLayer(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tm = layersArray[i];\n\n\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!m.__parent) {\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._removeLayer(m, true, true);\n\t\t\t\tthis.fire('layerremove', { layer: m });\n\n\t\t\t\tif (fg.hasLayer(m)) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Fix up the clusters and markers on the map\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Removes all layers from the MarkerClusterGroup\n\t\tclearLayers: function () {\n\t\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\n\n\t\t\t//If we aren't on the map (yet), blow away the markers we know of\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering = [];\n\t\t\t\tthis._needsRemoving = [];\n\t\t\t\tdelete this._gridClusters;\n\t\t\t\tdelete this._gridUnclustered;\n\t\t\t}\n\n\t\t\tif (this._noanimationUnspiderfy) {\n\t\t\t\tthis._noanimationUnspiderfy();\n\t\t\t}\n\n\t\t\t//Remove all the visible layers\n\t\t\tthis._featureGroup.clearLayers();\n\t\t\tthis._nonPointGroup.clearLayers();\n\n\t\t\tthis.eachLayer(function (marker) {\n\t\t\t\tmarker.off(this._childMarkerEventHandlers, this);\n\t\t\t\tdelete marker.__parent;\n\t\t\t}, this);\n\n\t\t\tif (this._map) {\n\t\t\t\t//Reset _topClusterLevel and the DistanceGrids\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Override FeatureGroup.getBounds as it doesn't work\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tbounds.extend(this._topClusterLevel._bounds);\n\t\t\t}\n\n\t\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\n\t\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\n\t\t\t}\n\n\t\t\tbounds.extend(this._nonPointGroup.getBounds());\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Overrides LayerGroup.eachLayer\n\t\teachLayer: function (method, context) {\n\t\t\tvar markers = this._needsClustering.slice(),\n\t\t\t\tneedsRemoving = this._needsRemoving,\n\t\t\t\tthisNeedsRemoving, i, j;\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\n\t\t\t}\n\n\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\tthisNeedsRemoving = true;\n\n\t\t\t\tfor (j = needsRemoving.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (needsRemoving[j].layer === markers[i]) {\n\t\t\t\t\t\tthisNeedsRemoving = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (thisNeedsRemoving) {\n\t\t\t\t\tmethod.call(context, markers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._nonPointGroup.eachLayer(method, context);\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayers\n\t\tgetLayers: function () {\n\t\t\tvar layers = [];\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tlayers.push(l);\n\t\t\t});\n\t\t\treturn layers;\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayer, WARNING: Really bad performance\n\t\tgetLayer: function (id) {\n\t\t\tvar result = null;\n\n\t\t\tid = parseInt(id, 10);\n\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tif (L.stamp(l) === id) {\n\t\t\t\t\tresult = l;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t//Returns true if the given layer is in this MarkerClusterGroup\n\t\thasLayer: function (layer) {\n\t\t\tif (!layer) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, anArray = this._needsClustering;\n\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === layer) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanArray = this._needsRemoving;\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i].layer === layer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\n\t\t},\n\n\t\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n\t\tzoomToShowLayer: function (layer, callback) {\n\n\t\t\tvar map = this._map;\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = function () {};\n\t\t\t}\n\n\t\t\tvar showMarker = function () {\n\t\t\t\t// Assumes that map.hasLayer checks for direct appearance on map, not recursively calling\n\t\t\t\t// hasLayer on Layer Groups that are on map (typically not calling this MarkerClusterGroup.hasLayer, which would always return true)\n\t\t\t\tif ((map.hasLayer(layer) || map.hasLayer(layer.__parent)) && !this._inZoomAnimation) {\n\t\t\t\t\tthis._map.off('moveend', showMarker, this);\n\t\t\t\t\tthis.off('animationend', showMarker, this);\n\n\t\t\t\t\tif (map.hasLayer(layer)) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if (layer.__parent._icon) {\n\t\t\t\t\t\tthis.once('spiderfied', callback, this);\n\t\t\t\t\t\tlayer.__parent.spiderfy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\n\t\t\t\t//Layer is visible ond on screen, immediate return\n\t\t\t\tcallback();\n\t\t\t} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {\n\t\t\t\t//Layer should be visible at this zoom level. It must not be on screen so just pan over to it\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis._map.panTo(layer.getLatLng());\n\t\t\t} else {\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis.on('animationend', showMarker, this);\n\t\t\t\tlayer.__parent.zoomToBounds();\n\t\t\t}\n\t\t},\n\n\t\t//Overrides FeatureGroup.onAdd\n\t\tonAdd: function (map) {\n\t\t\tthis._map = map;\n\t\t\tvar i, l, layer;\n\n\t\t\tif (!isFinite(this._map.getMaxZoom())) {\n\t\t\t\tthrow \"Map has no maxZoom specified\";\n\t\t\t}\n\n\t\t\tthis._featureGroup.addTo(map);\n\t\t\tthis._nonPointGroup.addTo(map);\n\n\t\t\tif (!this._gridClusters) {\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\tthis._maxLat = map.options.crs.projection.MAX_LATITUDE;\n\n\t\t\t//Restore all the positions as they are in the MCG before removing them\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tlayer.newlatlng = layer.layer._latlng;\n\t\t\t\tlayer.layer._latlng = layer.latlng;\n\t\t\t}\n\t\t\t//Remove them, then restore their new positions\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tthis._removeLayer(layer.layer, true);\n\t\t\t\tlayer.layer._latlng = layer.newlatlng;\n\t\t\t}\n\t\t\tthis._needsRemoving = [];\n\n\t\t\t//Remember the current zoom level and bounds\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._map.on('zoomend', this._zoomEnd, this);\n\t\t\tthis._map.on('moveend', this._moveEnd, this);\n\n\t\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnAdd();\n\t\t\t}\n\n\t\t\tthis._bindEvents();\n\n\t\t\t//Actually add our markers to the map:\n\t\t\tl = this._needsClustering;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis.addLayers(l, true);\n\t\t},\n\n\t\t//Overrides FeatureGroup.onRemove\n\t\tonRemove: function (map) {\n\t\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\t\tmap.off('moveend', this._moveEnd, this);\n\n\t\t\tthis._unbindEvents();\n\n\t\t\t//In case we are in a cluster animation\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\n\t\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnRemove();\n\t\t\t}\n\n\t\t\tdelete this._maxLat;\n\n\t\t\t//Clean up all the layers we added to the map\n\t\t\tthis._hideCoverage();\n\t\t\tthis._featureGroup.remove();\n\t\t\tthis._nonPointGroup.remove();\n\n\t\t\tthis._featureGroup.clearLayers();\n\n\t\t\tthis._map = null;\n\t\t},\n\n\t\tgetVisibleParent: function (marker) {\n\t\t\tvar vMarker = marker;\n\t\t\twhile (vMarker && !vMarker._icon) {\n\t\t\t\tvMarker = vMarker.__parent;\n\t\t\t}\n\t\t\treturn vMarker || null;\n\t\t},\n\n\t\t//Remove the given object from the given array\n\t\t_arraySplice: function (anArray, obj) {\n\t\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === obj) {\n\t\t\t\t\tanArray.splice(i, 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.\n\t\t * @param marker to be removed from _gridUnclustered.\n\t\t * @param z integer bottom start zoom level (included)\n\t\t * @private\n\t\t */\n\t\t_removeFromGridUnclustered: function (marker, z) {\n\t\t\tvar map = this._map,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\tfor (; z >= minZoom; z--) {\n\t\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_childMarkerDragStart: function (e) {\n\t\t\te.target.__dragStart = e.target._latlng;\n\t\t},\n\n\t\t_childMarkerMoved: function (e) {\n\t\t\tif (!this._ignoreMove && !e.target.__dragStart) {\n\t\t\t\tvar isPopupOpen = e.target._popup && e.target._popup.isOpen();\n\n\t\t\t\tthis._moveChild(e.target, e.oldLatLng, e.latlng);\n\n\t\t\t\tif (isPopupOpen) {\n\t\t\t\t\te.target.openPopup();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_moveChild: function (layer, from, to) {\n\t\t\tlayer._latlng = from;\n\t\t\tthis.removeLayer(layer);\n\n\t\t\tlayer._latlng = to;\n\t\t\tthis.addLayer(layer);\n\t\t},\n\n\t\t_childMarkerDragEnd: function (e) {\n\t\t\tvar dragStart = e.target.__dragStart;\n\t\t\tdelete e.target.__dragStart;\n\t\t\tif (dragStart) {\n\t\t\t\tthis._moveChild(e.target, dragStart, e.target._latlng);\n\t\t\t}\t\t\n\t\t},\n\n\n\t\t//Internal function for removing a marker from everything.\n\t\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n\t\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t\tgridUnclustered = this._gridUnclustered,\n\t\t\t\tfg = this._featureGroup,\n\t\t\t\tmap = this._map,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Remove the marker from distance clusters it might be in\n\t\t\tif (removeFromDistanceGrid) {\n\t\t\t\tthis._removeFromGridUnclustered(marker, this._maxZoom);\n\t\t\t}\n\n\t\t\t//Work our way up the clusters removing them as we go if required\n\t\t\tvar cluster = marker.__parent,\n\t\t\t\tmarkers = cluster._markers,\n\t\t\t\totherMarker;\n\n\t\t\t//Remove the marker from the immediate parents marker list\n\t\t\tthis._arraySplice(markers, marker);\n\n\t\t\twhile (cluster) {\n\t\t\t\tcluster._childCount--;\n\t\t\t\tcluster._boundsNeedUpdate = true;\n\n\t\t\t\tif (cluster._zoom < minZoom) {\n\t\t\t\t\t//Top level, do nothing\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\n\t\t\t\t\t//We need to push the other marker up to the parent\n\t\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n\n\t\t\t\t\t//Update distance grid\n\t\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n\t\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n\n\t\t\t\t\t//Move otherMarker up to parent\n\t\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\n\t\t\t\t\tcluster.__parent._markers.push(otherMarker);\n\t\t\t\t\totherMarker.__parent = cluster.__parent;\n\n\t\t\t\t\tif (cluster._icon) {\n\t\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\n\t\t\t\t\t\tfg.removeLayer(cluster);\n\t\t\t\t\t\tif (!dontUpdateMap) {\n\t\t\t\t\t\t\tfg.addLayer(otherMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._iconNeedsUpdate = true;\n\t\t\t\t}\n\n\t\t\t\tcluster = cluster.__parent;\n\t\t\t}\n\n\t\t\tdelete marker.__parent;\n\t\t},\n\n\t\t_isOrIsParent: function (el, oel) {\n\t\t\twhile (oel) {\n\t\t\t\tif (el === oel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\toel = oel.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t//Override L.Evented.fire\n\t\tfire: function (type, data, propagate) {\n\t\t\tif (data && data.layer instanceof L.MarkerCluster) {\n\t\t\t\t//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\n\t\t\t\tif (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttype = 'cluster' + type;\n\t\t\t}\n\n\t\t\tL.FeatureGroup.prototype.fire.call(this, type, data, propagate);\n\t\t},\n\n\t\t//Override L.Evented.listens\n\t\tlistens: function (type, propagate) {\n\t\t\treturn L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);\n\t\t},\n\n\t\t//Default functionality\n\t\t_defaultIconCreateFunction: function (cluster) {\n\t\t\tvar childCount = cluster.getChildCount();\n\n\t\t\tvar c = ' marker-cluster-';\n\t\t\tif (childCount < 10) {\n\t\t\t\tc += 'small';\n\t\t\t} else if (childCount < 100) {\n\t\t\t\tc += 'medium';\n\t\t\t} else {\n\t\t\t\tc += 'large';\n\t\t\t}\n\n\t\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n\t\t},\n\n\t\t_bindEvents: function () {\n\t\t\tvar map = this._map,\n\t\t\t    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t    showCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t    spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom;\n\n\t\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.on('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\n\t\t\t//Show convex hull (boundary) polygon on mouse over\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.on('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.on('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.on('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomOrSpiderfy: function (e) {\n\t\t\tvar cluster = e.layer,\n\t\t\t    bottomCluster = cluster;\n\n\t\t\tif (e.type === 'clusterkeypress' && e.originalEvent && e.originalEvent.keyCode !== 13) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile (bottomCluster._childClusters.length === 1) {\n\t\t\t\tbottomCluster = bottomCluster._childClusters[0];\n\t\t\t}\n\n\t\t\tif (bottomCluster._zoom === this._maxZoom &&\n\t\t\t\tbottomCluster._childCount === cluster._childCount &&\n\t\t\t\tthis.options.spiderfyOnMaxZoom) {\n\n\t\t\t\t// All child markers are contained in a single cluster from this._maxZoom to this cluster.\n\t\t\t\tcluster.spiderfy();\n\t\t\t} else if (this.options.zoomToBoundsOnClick) {\n\t\t\t\tcluster.zoomToBounds();\n\t\t\t}\n\n\t\t\tif (this.options.spiderfyOnEveryZoom) {\n\t\t\t\tcluster.spiderfy();\n\t\t\t}\n\n\t\t\t// Focus the map again for keyboard users.\n\t\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\n\t\t\t\tthis._map._container.focus();\n\t\t\t}\n\t\t},\n\n\t\t_showCoverage: function (e) {\n\t\t\tvar map = this._map;\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tmap.removeLayer(this._shownPolygon);\n\t\t\t}\n\t\t\tif (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\n\t\t\t\tthis._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\n\t\t\t\tmap.addLayer(this._shownPolygon);\n\t\t\t}\n\t\t},\n\n\t\t_hideCoverage: function () {\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tthis._map.removeLayer(this._shownPolygon);\n\t\t\t\tthis._shownPolygon = null;\n\t\t\t}\n\t\t},\n\n\t\t_unbindEvents: function () {\n\t\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t\tspiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom,\n\t\t\t\tmap = this._map;\n\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.off('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.off('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.off('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.off('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomEnd: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._mergeSplitClusters();\n\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\t\t},\n\n\t\t_moveEnd: function () {\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar newBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);\n\n\t\t\tthis._currentShownBounds = newBounds;\n\t\t\treturn;\n\t\t},\n\n\t\t_generateInitialClusters: function () {\n\t\t\tvar maxZoom = Math.ceil(this._map.getMaxZoom()),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\tradius = this.options.maxClusterRadius,\n\t\t\t\tradiusFn = radius;\n\n\t\t\t//If we just set maxClusterRadius to a single number, we need to create\n\t\t\t//a simple function to return that number. Otherwise, we just have to\n\t\t\t//use the function we've passed in.\n\t\t\tif (typeof radius !== \"function\") {\n\t\t\t\tradiusFn = function () { return radius; };\n\t\t\t}\n\n\t\t\tif (this.options.disableClusteringAtZoom !== null) {\n\t\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\n\t\t\t}\n\t\t\tthis._maxZoom = maxZoom;\n\t\t\tthis._gridClusters = {};\n\t\t\tthis._gridUnclustered = {};\n\n\t\t\t//Set up DistanceGrids for each zoom\n\t\t\tfor (var zoom = maxZoom; zoom >= minZoom; zoom--) {\n\t\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t}\n\n\t\t\t// Instantiate the appropriate L.MarkerCluster class (animated or not).\n\t\t\tthis._topClusterLevel = new this._markerCluster(this, minZoom - 1);\n\t\t},\n\n\t\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n\t\t_addLayer: function (layer, zoom) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t    markerPoint, z;\n\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._overrideMarkerIcon(layer);\n\t\t\t}\n\n\t\t\tlayer.on(this._childMarkerEventHandlers, this);\n\n\t\t\t//Find the lowest zoom level to slot this one in\n\t\t\tfor (; zoom >= minZoom; zoom--) {\n\t\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n\n\t\t\t\t//Try find a cluster close by\n\t\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tclosest._addChild(layer);\n\t\t\t\t\tlayer.__parent = closest;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Try find a marker close by to form a new cluster with\n\t\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tvar parent = closest.__parent;\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tthis._removeLayer(closest, false);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Create new cluster with these 2 in it\n\n\t\t\t\t\tvar newCluster = new this._markerCluster(this, zoom, closest, layer);\n\t\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n\t\t\t\t\tclosest.__parent = newCluster;\n\t\t\t\t\tlayer.__parent = newCluster;\n\n\t\t\t\t\t//First create any new intermediate parent clusters that don't exist\n\t\t\t\t\tvar lastParent = newCluster;\n\t\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\n\t\t\t\t\t\tlastParent = new this._markerCluster(this, z, lastParent);\n\t\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n\t\t\t\t\t}\n\t\t\t\t\tparent._addChild(lastParent);\n\n\t\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\n\t\t\t\t\tthis._removeFromGridUnclustered(closest, zoom);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n\t\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\n\t\t\t}\n\n\t\t\t//Didn't get in anything, add us to the top\n\t\t\tthis._topClusterLevel._addChild(layer);\n\t\t\tlayer.__parent = this._topClusterLevel;\n\t\t\treturn;\n\t\t},\n\n\t\t/**\n\t\t * Refreshes the icon of all \"dirty\" visible clusters.\n\t\t * Non-visible \"dirty\" clusters will be updated when they are added to the map.\n\t\t * @private\n\t\t */\n\t\t_refreshClustersIcons: function () {\n\t\t\tthis._featureGroup.eachLayer(function (c) {\n\t\t\t\tif (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n\t\t\t\t\tc._updateIcon();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t//Enqueue code to fire after the marker expand/contract has happened\n\t\t_enqueue: function (fn) {\n\t\t\tthis._queue.push(fn);\n\t\t\tif (!this._queueTimeout) {\n\t\t\t\tthis._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\n\t\t\t}\n\t\t},\n\t\t_processQueue: function () {\n\t\t\tfor (var i = 0; i < this._queue.length; i++) {\n\t\t\t\tthis._queue[i].call(this);\n\t\t\t}\n\t\t\tthis._queue.length = 0;\n\t\t\tclearTimeout(this._queueTimeout);\n\t\t\tthis._queueTimeout = null;\n\t\t},\n\n\t\t//Merge and split any existing clusters that are too big or small\n\t\t_mergeSplitClusters: function () {\n\t\t\tvar mapZoom = Math.round(this._map._zoom);\n\n\t\t\t//In case we are starting to split before the animation finished\n\t\t\tthis._processQueue();\n\n\t\t\tif (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split\n\t\t\t\tthis._animationStart();\n\t\t\t\t//Remove clusters now off screen\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());\n\n\t\t\t\tthis._animationZoomIn(this._zoom, mapZoom);\n\n\t\t\t} else if (this._zoom > mapZoom) { //Zoom out, merge\n\t\t\t\tthis._animationStart();\n\n\t\t\t\tthis._animationZoomOut(this._zoom, mapZoom);\n\t\t\t} else {\n\t\t\t\tthis._moveEnd();\n\t\t\t}\n\t\t},\n\n\t\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n\t\t_getExpandedVisibleBounds: function () {\n\t\t\tif (!this.options.removeOutsideVisibleBounds) {\n\t\t\t\treturn this._mapBoundsInfinite;\n\t\t\t} else if (L.Browser.mobile) {\n\t\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds());\n\t\t\t}\n\n\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.\n\t\t},\n\n\t\t/**\n\t\t * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude\n\t\t * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).\n\t\t * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without\n\t\t * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,\n\t\t * making the user think that MCG \"eats\" them and never displays them again.\n\t\t * @param bounds L.LatLngBounds\n\t\t * @returns {L.LatLngBounds}\n\t\t * @private\n\t\t */\n\t\t_checkBoundsMaxLat: function (bounds) {\n\t\t\tvar maxLat = this._maxLat;\n\n\t\t\tif (maxLat !== undefined) {\n\t\t\t\tif (bounds.getNorth() >= maxLat) {\n\t\t\t\t\tbounds._northEast.lat = Infinity;\n\t\t\t\t}\n\t\t\t\tif (bounds.getSouth() <= -maxLat) {\n\t\t\t\t\tbounds._southWest.lat = -Infinity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Shared animation code\n\t\t_animationAddLayerNonAnimated: function (layer, newCluster) {\n\t\t\tif (newCluster === layer) {\n\t\t\t\tthis._featureGroup.addLayer(layer);\n\t\t\t} else if (newCluster._childCount === 2) {\n\t\t\t\tnewCluster._addToMap();\n\n\t\t\t\tvar markers = newCluster.getAllChildMarkers();\n\t\t\t\tthis._featureGroup.removeLayer(markers[0]);\n\t\t\t\tthis._featureGroup.removeLayer(markers[1]);\n\t\t\t} else {\n\t\t\t\tnewCluster._updateIcon();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extracts individual (i.e. non-group) layers from a Layer Group.\n\t\t * @param group to extract layers from.\n\t\t * @param output {Array} in which to store the extracted layers.\n\t\t * @returns {*|Array}\n\t\t * @private\n\t\t */\n\t\t_extractNonGroupLayers: function (group, output) {\n\t\t\tvar layers = group.getLayers(),\n\t\t\t    i = 0,\n\t\t\t    layer;\n\n\t\t\toutput = output || [];\n\n\t\t\tfor (; i < layers.length; i++) {\n\t\t\t\tlayer = layers[i];\n\n\t\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\t\tthis._extractNonGroupLayers(layer, output);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\toutput.push(layer);\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\t\t/**\n\t\t * Implements the singleMarkerMode option.\n\t\t * @param layer Marker to re-style using the Clusters iconCreateFunction.\n\t\t * @returns {L.Icon} The newly created icon.\n\t\t * @private\n\t\t */\n\t\t_overrideMarkerIcon: function (layer) {\n\t\t\tvar icon = layer.options.icon = this.options.iconCreateFunction({\n\t\t\t\tgetChildCount: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t},\n\t\t\t\tgetAllChildMarkers: function () {\n\t\t\t\t\treturn [layer];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn icon;\n\t\t}\n\t});\n\n\t// Constant bounds used in case option \"removeOutsideVisibleBounds\" is set to false.\n\tL.MarkerClusterGroup.include({\n\t\t_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))\n\t});\n\n\tL.MarkerClusterGroup.include({\n\t\t_noAnimation: {\n\t\t\t//Non Animated versions of everything\n\t\t\t_animationStart: function () {\n\t\t\t\t//Do nothing...\n\t\t\t},\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\n\t\t\t}\n\t\t},\n\n\t\t_withAnimation: {\n\t\t\t//Animated versions here\n\t\t\t_animationStart: function () {\n\t\t\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\n\t\t\t\tthis._inZoomAnimation++;\n\t\t\t},\n\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\t    fg = this._featureGroup,\n\t\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\t    i;\n\n\t\t\t\tthis._ignoreMove = true;\n\n\t\t\t\t//Add all children of current clusters to map and remove those clusters from map\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\tvar startPos = c._latlng,\n\t\t\t\t\t    markers  = c._markers,\n\t\t\t\t\t    m;\n\n\t\t\t\t\tif (!bounds.contains(startPos)) {\n\t\t\t\t\t\tstartPos = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Fade out old cluster\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Remove all markers that aren't visible any more\n\t\t\t\t\t//TODO: Do we actually need to do this on the higher levels too?\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\t\t\t\t\t\tif (!bounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\tthis._forceLayout();\n\n\t\t\t\t//Update opacities\n\t\t\t\tthis._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n\t\t\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\n\t\t\t\tfg.eachLayer(function (n) {\n\t\t\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\n\t\t\t\t\t\tn.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\n\t\t\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\n\t\t\t\t});\n\n\t\t\t\tthis._ignoreMove = false;\n\n\t\t\t\t//Remove the old clusters and close the zoom animation\n\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t});\n\n\t\t\t\t\tthis._animationEnd();\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n\n\t\t\t\t//Need to add markers for those that weren't on the map before but are now\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t\t//Remove markers that were on the map before but won't be now\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t},\n\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tvar me = this,\n\t\t\t\t    fg = this._featureGroup;\n\n\t\t\t\tfg.addLayer(layer);\n\t\t\t\tif (newCluster !== layer) {\n\t\t\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\n\n\t\t\t\t\t\tnewCluster._updateIcon();\n\t\t\t\t\t\tthis._forceLayout();\n\t\t\t\t\t\tthis._animationStart();\n\n\t\t\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n\t\t\t\t\t\tlayer.clusterHide();\n\n\t\t\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t\t\tfg.removeLayer(layer);\n\t\t\t\t\t\t\tlayer.clusterShow();\n\n\t\t\t\t\t\t\tme._animationEnd();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t} else { //Just became a cluster\n\t\t\t\t\t\tthis._forceLayout();\n\n\t\t\t\t\t\tme._animationStart();\n\t\t\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Private methods for animated versions.\n\t\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\n\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Animate all of the markers in the clusters to move to their cluster center point\n\t\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\n\n\t\t\tvar me = this;\n\n\t\t\t//Update the opacity (If we immediately set it they won't animate)\n\t\t\tthis._forceLayout();\n\t\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n\n\t\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\n\t\t\t//When the animations are done, tidy up\n\t\t\tthis._enqueue(function () {\n\n\t\t\t\t//This cluster stopped being a cluster before the timeout fired\n\t\t\t\tif (cluster._childCount === 1) {\n\t\t\t\t\tvar m = cluster._markers[0];\n\t\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n\t\t\t\t\tthis._ignoreMove = true;\n\t\t\t\t\tm.setLatLng(m.getLatLng());\n\t\t\t\t\tthis._ignoreMove = false;\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._recursively(bounds, newZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tme._animationEnd();\n\t\t\t});\n\t\t},\n\n\t\t_animationEnd: function () {\n\t\t\tif (this._map) {\n\t\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\t\t\t}\n\t\t\tthis._inZoomAnimation--;\n\t\t\tthis.fire('animationend');\n\t\t},\n\n\t\t//Force a browser layout of stuff in the map\n\t\t// Should apply the current opacity and location to all elements so we can update them again for an animation\n\t\t_forceLayout: function () {\n\t\t\t//In my testing this works, infact offsetWidth of any element seems to work.\n\t\t\t//Could loop all this._layers and do this for each _icon if it stops working\n\n\t\t\tL.Util.falseFn(document.body.offsetWidth);\n\t\t}\n\t});\n\n\tL.markerClusterGroup = function (options) {\n\t\treturn new L.MarkerClusterGroup(options);\n\t};\n\n\tvar MarkerCluster = L.MarkerCluster = L.Marker.extend({\n\t\toptions: L.Icon.prototype.options,\n\n\t\tinitialize: function (group, zoom, a, b) {\n\n\t\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),\n\t            { icon: this, pane: group.options.clusterPane });\n\n\t\t\tthis._group = group;\n\t\t\tthis._zoom = zoom;\n\n\t\t\tthis._markers = [];\n\t\t\tthis._childClusters = [];\n\t\t\tthis._childCount = 0;\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tthis._boundsNeedUpdate = true;\n\n\t\t\tthis._bounds = new L.LatLngBounds();\n\n\t\t\tif (a) {\n\t\t\t\tthis._addChild(a);\n\t\t\t}\n\t\t\tif (b) {\n\t\t\t\tthis._addChild(b);\n\t\t\t}\n\t\t},\n\n\t\t//Recursively retrieve all child markers of this cluster\n\t\tgetAllChildMarkers: function (storageArray, ignoreDraggedMarker) {\n\t\t\tstorageArray = storageArray || [];\n\n\t\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray, ignoreDraggedMarker);\n\t\t\t}\n\n\t\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\n\t\t\t\tif (ignoreDraggedMarker && this._markers[j].__dragStart) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstorageArray.push(this._markers[j]);\n\t\t\t}\n\n\t\t\treturn storageArray;\n\t\t},\n\n\t\t//Returns the count of how many child markers we have\n\t\tgetChildCount: function () {\n\t\t\treturn this._childCount;\n\t\t},\n\n\t\t//Zoom to the minimum of showing all of the child markers, or the extents of this cluster\n\t\tzoomToBounds: function (fitBoundsOptions) {\n\t\t\tvar childClusters = this._childClusters.slice(),\n\t\t\t\tmap = this._group._map,\n\t\t\t\tboundsZoom = map.getBoundsZoom(this._bounds),\n\t\t\t\tzoom = this._zoom + 1,\n\t\t\t\tmapZoom = map.getZoom(),\n\t\t\t\ti;\n\n\t\t\t//calculate how far we need to zoom down to see all of the markers\n\t\t\twhile (childClusters.length > 0 && boundsZoom > zoom) {\n\t\t\t\tzoom++;\n\t\t\t\tvar newClusters = [];\n\t\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\t\tnewClusters = newClusters.concat(childClusters[i]._childClusters);\n\t\t\t\t}\n\t\t\t\tchildClusters = newClusters;\n\t\t\t}\n\n\t\t\tif (boundsZoom > zoom) {\n\t\t\t\tthis._group._map.setView(this._latlng, zoom);\n\t\t\t} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n\t\t\t\tthis._group._map.setView(this._latlng, mapZoom + 1);\n\t\t\t} else {\n\t\t\t\tthis._group._map.fitBounds(this._bounds, fitBoundsOptions);\n\t\t\t}\n\t\t},\n\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\t\t\tbounds.extend(this._bounds);\n\t\t\treturn bounds;\n\t\t},\n\n\t\t_updateIcon: function () {\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tif (this._icon) {\n\t\t\t\tthis.setIcon(this);\n\t\t\t}\n\t\t},\n\n\t\t//Cludge for Icon, we pretend to be an icon for performance\n\t\tcreateIcon: function () {\n\t\t\tif (this._iconNeedsUpdate) {\n\t\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\n\t\t\t\tthis._iconNeedsUpdate = false;\n\t\t\t}\n\t\t\treturn this._iconObj.createIcon();\n\t\t},\n\t\tcreateShadow: function () {\n\t\t\treturn this._iconObj.createShadow();\n\t\t},\n\n\n\t\t_addChild: function (new1, isNotificationFromChild) {\n\n\t\t\tthis._iconNeedsUpdate = true;\n\n\t\t\tthis._boundsNeedUpdate = true;\n\t\t\tthis._setClusterCenter(new1);\n\n\t\t\tif (new1 instanceof L.MarkerCluster) {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._childClusters.push(new1);\n\t\t\t\t\tnew1.__parent = this;\n\t\t\t\t}\n\t\t\t\tthis._childCount += new1._childCount;\n\t\t\t} else {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._markers.push(new1);\n\t\t\t\t}\n\t\t\t\tthis._childCount++;\n\t\t\t}\n\n\t\t\tif (this.__parent) {\n\t\t\t\tthis.__parent._addChild(new1, true);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.\n\t\t * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.\n\t\t * @private\n\t\t */\n\t\t_setClusterCenter: function (child) {\n\t\t\tif (!this._cLatLng) {\n\t\t\t\t// when clustering, take position of the first point as the cluster center\n\t\t\t\tthis._cLatLng = child._cLatLng || child._latlng;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Assigns impossible bounding values so that the next extend entirely determines the new bounds.\n\t\t * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.\n\t\t * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.\n\t\t * @private\n\t\t */\n\t\t_resetBounds: function () {\n\t\t\tvar bounds = this._bounds;\n\n\t\t\tif (bounds._southWest) {\n\t\t\t\tbounds._southWest.lat = Infinity;\n\t\t\t\tbounds._southWest.lng = Infinity;\n\t\t\t}\n\t\t\tif (bounds._northEast) {\n\t\t\t\tbounds._northEast.lat = -Infinity;\n\t\t\t\tbounds._northEast.lng = -Infinity;\n\t\t\t}\n\t\t},\n\n\t\t_recalculateBounds: function () {\n\t\t\tvar markers = this._markers,\n\t\t\t    childClusters = this._childClusters,\n\t\t\t    latSum = 0,\n\t\t\t    lngSum = 0,\n\t\t\t    totalCount = this._childCount,\n\t\t\t    i, child, childLatLng, childCount;\n\n\t\t\t// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.\n\t\t\tif (totalCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Reset rather than creating a new object, for performance.\n\t\t\tthis._resetBounds();\n\n\t\t\t// Child markers.\n\t\t\tfor (i = 0; i < markers.length; i++) {\n\t\t\t\tchildLatLng = markers[i]._latlng;\n\n\t\t\t\tthis._bounds.extend(childLatLng);\n\n\t\t\t\tlatSum += childLatLng.lat;\n\t\t\t\tlngSum += childLatLng.lng;\n\t\t\t}\n\n\t\t\t// Child clusters.\n\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\tchild = childClusters[i];\n\n\t\t\t\t// Re-compute child bounds and weighted position first if necessary.\n\t\t\t\tif (child._boundsNeedUpdate) {\n\t\t\t\t\tchild._recalculateBounds();\n\t\t\t\t}\n\n\t\t\t\tthis._bounds.extend(child._bounds);\n\n\t\t\t\tchildLatLng = child._wLatLng;\n\t\t\t\tchildCount = child._childCount;\n\n\t\t\t\tlatSum += childLatLng.lat * childCount;\n\t\t\t\tlngSum += childLatLng.lng * childCount;\n\t\t\t}\n\n\t\t\tthis._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);\n\n\t\t\t// Reset dirty flag.\n\t\t\tthis._boundsNeedUpdate = false;\n\t\t},\n\n\t\t//Set our markers position as given and add it to the map\n\t\t_addToMap: function (startPos) {\n\t\t\tif (startPos) {\n\t\t\t\tthis._backupLatlng = this._latlng;\n\t\t\t\tthis.setLatLng(startPos);\n\t\t\t}\n\t\t\tthis._group._featureGroup.addLayer(this);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar markers = c._markers,\n\t\t\t\t\t\ti, m;\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\n\t\t\t\t\t\t//Only do it if the icon is still on the map\n\t\t\t\t\t\tif (m._icon) {\n\t\t\t\t\t\t\tm._setPos(center);\n\t\t\t\t\t\t\tm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar childClusters = c._childClusters,\n\t\t\t\t\t\tj, cm;\n\t\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tcm = childClusters[j];\n\t\t\t\t\t\tif (cm._icon) {\n\t\t\t\t\t\t\tcm._setPos(center);\n\t\t\t\t\t\t\tcm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {\n\t\t\tthis._recursively(bounds, newZoomLevel, mapMinZoom,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n\n\t\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n\t\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t}\n\n\t\t\t\t\tc._addToMap();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {\n\t\t\t\tc.clusterShow();\n\t\t\t});\n\t\t},\n\n\t\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tif (zoomLevel === c._zoom) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Add our child markers at startPos (so they can be animated out)\n\t\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar nm = c._markers[i];\n\n\t\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (startPos) {\n\t\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\n\n\t\t\t\t\t\t\tnm.setLatLng(startPos);\n\t\t\t\t\t\t\tif (nm.clusterHide) {\n\t\t\t\t\t\t\t\tnm.clusterHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tc._group._featureGroup.addLayer(nm);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._addToMap(startPos);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyRestoreChildPositions: function (zoomLevel) {\n\t\t\t//Fix positions of child markers\n\t\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\n\t\t\t\tvar nm = this._markers[i];\n\t\t\t\tif (nm._backupLatlng) {\n\t\t\t\t\tnm.setLatLng(nm._backupLatlng);\n\t\t\t\t\tdelete nm._backupLatlng;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoomLevel - 1 === this._zoom) {\n\t\t\t\t//Reposition child clusters\n\t\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\tthis._childClusters[j]._restorePosition();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\n\t\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_restorePosition: function () {\n\t\t\tif (this._backupLatlng) {\n\t\t\t\tthis.setLatLng(this._backupLatlng);\n\t\t\t\tdelete this._backupLatlng;\n\t\t\t}\n\t\t},\n\n\t\t//exceptBounds: If set, don't remove any markers/clusters in it\n\t\t_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\n\t\t\tvar m, i;\n\t\t\tthis._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove markers at every level\n\t\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._markers[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove child clusters at just the bottom level\n\t\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._childClusters[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t//Run the given functions recursively to this and child clusters\n\t\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n\t\t// zoomLevelToStart: zoom level to start running functions (inclusive)\n\t\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\n\t\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n\t\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n\t\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n\t\t\tvar childClusters = this._childClusters,\n\t\t\t    zoom = this._zoom,\n\t\t\t    i, c;\n\n\t\t\tif (zoomLevelToStart <= zoom) {\n\t\t\t\tif (runAtEveryLevel) {\n\t\t\t\t\trunAtEveryLevel(this);\n\t\t\t\t}\n\t\t\t\tif (runAtBottomLevel && zoom === zoomLevelToStop) {\n\t\t\t\t\trunAtBottomLevel(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\n\t\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tc = childClusters[i];\n\t\t\t\t\tif (c._boundsNeedUpdate) {\n\t\t\t\t\t\tc._recalculateBounds();\n\t\t\t\t\t}\n\t\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\n\t\t_isSingleParent: function () {\n\t\t\t//Don't need to check this._markers as the rest won't work if there are any\n\t\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n\t\t}\n\t});\n\n\t/*\n\t* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\n\t* \n\t* They work as setOpacity(0) and setOpacity(1) respectively, but\n\t* don't overwrite the options.opacity\n\t* \n\t*/\n\n\tL.Marker.include({\n\t\tclusterHide: function () {\n\t\t\tvar backup = this.options.opacity;\n\t\t\tthis.setOpacity(0);\n\t\t\tthis.options.opacity = backup;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\tclusterShow: function () {\n\t\t\treturn this.setOpacity(this.options.opacity);\n\t\t}\n\t});\n\n\tL.DistanceGrid = function (cellSize) {\n\t\tthis._cellSize = cellSize;\n\t\tthis._sqCellSize = cellSize * cellSize;\n\t\tthis._grid = {};\n\t\tthis._objectPoint = { };\n\t};\n\n\tL.DistanceGrid.prototype = {\n\n\t\taddObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    stamp = L.Util.stamp(obj);\n\n\t\t\tthis._objectPoint[stamp] = point;\n\n\t\t\tcell.push(obj);\n\t\t},\n\n\t\tupdateObject: function (obj, point) {\n\t\t\tthis.removeObject(obj);\n\t\t\tthis.addObject(obj, point);\n\t\t},\n\n\t\t//Returns true if the object was found\n\t\tremoveObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    i, len;\n\n\t\t\tdelete this._objectPoint[L.Util.stamp(obj)];\n\n\t\t\tfor (i = 0, len = cell.length; i < len; i++) {\n\t\t\t\tif (cell[i] === obj) {\n\n\t\t\t\t\tcell.splice(i, 1);\n\n\t\t\t\t\tif (len === 1) {\n\t\t\t\t\t\tdelete row[x];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t},\n\n\t\teachObject: function (fn, context) {\n\t\t\tvar i, j, k, len, row, cell, removed,\n\t\t\t    grid = this._grid;\n\n\t\t\tfor (i in grid) {\n\t\t\t\trow = grid[i];\n\n\t\t\t\tfor (j in row) {\n\t\t\t\t\tcell = row[j];\n\n\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tk--;\n\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetNearObject: function (point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    i, j, k, row, cell, len, obj, dist,\n\t\t\t    objectPoint = this._objectPoint,\n\t\t\t    closestDistSq = this._sqCellSize,\n\t\t\t    closest = null;\n\n\t\t\tfor (i = y - 1; i <= y + 1; i++) {\n\t\t\t\trow = this._grid[i];\n\t\t\t\tif (row) {\n\n\t\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\n\t\t\t\t\t\tcell = row[j];\n\t\t\t\t\t\tif (cell) {\n\n\t\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\t\tobj = cell[k];\n\t\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n\t\t\t\t\t\t\t\tif (dist < closestDistSq ||\n\t\t\t\t\t\t\t\t\tdist <= closestDistSq && closest === null) {\n\t\t\t\t\t\t\t\t\tclosestDistSq = dist;\n\t\t\t\t\t\t\t\t\tclosest = obj;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn closest;\n\t\t},\n\n\t\t_getCoord: function (x) {\n\t\t\tvar coord = Math.floor(x / this._cellSize);\n\t\t\treturn isFinite(coord) ? coord : x;\n\t\t},\n\n\t\t_sqDist: function (p, p2) {\n\t\t\tvar dx = p2.x - p.x,\n\t\t\t    dy = p2.y - p.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\t};\n\n\t/* Copyright (c) 2012 the authors listed at the following URL, and/or\n\tthe authors of referenced articles or incorporated external code:\n\thttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\n\tPermission is hereby granted, free of charge, to any person obtaining\n\ta copy of this software and associated documentation files (the\n\t\"Software\"), to deal in the Software without restriction, including\n\twithout limitation the rights to use, copy, modify, merge, publish,\n\tdistribute, sublicense, and/or sell copies of the Software, and to\n\tpermit persons to whom the Software is furnished to do so, subject to\n\tthe following conditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\tMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n\tCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n\tTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n\t*/\n\n\t(function () {\n\t\tL.QuickHull = {\n\n\t\t\t/*\n\t\t\t * @param {Object} cpt a point to be measured from the baseline\n\t\t\t * @param {Array} bl the baseline, as represented by a two-element\n\t\t\t *   array of latlng objects.\n\t\t\t * @returns {Number} an approximate distance measure\n\t\t\t */\n\t\t\tgetDistant: function (cpt, bl) {\n\t\t\t\tvar vY = bl[1].lat - bl[0].lat,\n\t\t\t\t\tvX = bl[0].lng - bl[1].lng;\n\t\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * @param {Array} baseLine a two-element array of latlng objects\n\t\t\t *   representing the baseline to project from\n\t\t\t * @param {Array} latLngs an array of latlng objects\n\t\t\t * @returns {Object} the maximum point and all new points to stay\n\t\t\t *   in consideration for the hull.\n\t\t\t */\n\t\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\n\t\t\t\tvar maxD = 0,\n\t\t\t\t\tmaxPt = null,\n\t\t\t\t\tnewPoints = [],\n\t\t\t\t\ti, pt, d;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tpt = latLngs[i];\n\t\t\t\t\td = this.getDistant(pt, baseLine);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\tnewPoints.push(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d > maxD) {\n\t\t\t\t\t\tmaxD = d;\n\t\t\t\t\t\tmaxPt = pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { maxPoint: maxPt, newPoints: newPoints };\n\t\t\t},\n\n\n\t\t\t/*\n\t\t\t * Given a baseline, compute the convex hull of latLngs as an array\n\t\t\t * of latLngs.\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tbuildConvexHull: function (baseLine, latLngs) {\n\t\t\t\tvar convexHullBaseLines = [],\n\t\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n\n\t\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\treturn convexHullBaseLines;\n\t\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\n\t\t\t\t\treturn [baseLine[0]];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * Given an array of latlngs, compute a convex hull as an array\n\t\t\t * of latlngs\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tgetConvexHull: function (latLngs) {\n\t\t\t\t// find first baseline\n\t\t\t\tvar maxLat = false, minLat = false,\n\t\t\t\t\tmaxLng = false, minLng = false,\n\t\t\t\t\tmaxLatPt = null, minLatPt = null,\n\t\t\t\t\tmaxLngPt = null, minLngPt = null,\n\t\t\t\t\tmaxPt = null, minPt = null,\n\t\t\t\t\ti;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar pt = latLngs[i];\n\t\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\n\t\t\t\t\t\tmaxLatPt = pt;\n\t\t\t\t\t\tmaxLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLat === false || pt.lat < minLat) {\n\t\t\t\t\t\tminLatPt = pt;\n\t\t\t\t\t\tminLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxLng === false || pt.lng > maxLng) {\n\t\t\t\t\t\tmaxLngPt = pt;\n\t\t\t\t\t\tmaxLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLng === false || pt.lng < minLng) {\n\t\t\t\t\t\tminLngPt = pt;\n\t\t\t\t\t\tminLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (minLat !== maxLat) {\n\t\t\t\t\tminPt = minLatPt;\n\t\t\t\t\tmaxPt = maxLatPt;\n\t\t\t\t} else {\n\t\t\t\t\tminPt = minLngPt;\n\t\t\t\t\tmaxPt = maxLngPt;\n\t\t\t\t}\n\n\t\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\n\t\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t};\n\t}());\n\n\tL.MarkerCluster.include({\n\t\tgetConvexHull: function () {\n\t\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\t\tpoints = [],\n\t\t\t\tp, i;\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tp = childMarkers[i].getLatLng();\n\t\t\t\tpoints.push(p);\n\t\t\t}\n\n\t\t\treturn L.QuickHull.getConvexHull(points);\n\t\t}\n\t});\n\n\t//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n\t//Huge thanks to jawj for implementing it first to make my job easy :-)\n\n\tL.MarkerCluster.include({\n\n\t\t_2PI: Math.PI * 2,\n\t\t_circleFootSeparation: 25, //related to circumference of circle\n\t\t_circleStartAngle: 0,\n\n\t\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\n\t\t_spiralLengthStart: 11,\n\t\t_spiralLengthFactor: 5,\n\n\t\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\n\t\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\n\n\t\tspiderfy: function () {\n\t\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar childMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\n\t\t\t\tpositions;\n\n\t\t\tthis._group._unspiderfy();\n\t\t\tthis._group._spiderfied = this;\n\n\t\t\t//TODO Maybe: childMarkers order by distance to center\n\n\t\t\tif (this._group.options.spiderfyShapePositions) {\n\t\t\t\tpositions = this._group.options.spiderfyShapePositions(childMarkers.length, center);\n\t\t\t} else if (childMarkers.length >= this._circleSpiralSwitchover) {\n\t\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\n\t\t\t} else {\n\t\t\t\tcenter.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.\n\t\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\n\t\t\t}\n\n\t\t\tthis._animationSpiderfy(childMarkers, positions);\n\t\t},\n\n\t\tunspiderfy: function (zoomDetails) {\n\t\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n\t\t\tif (this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._animationUnspiderfy(zoomDetails);\n\n\t\t\tthis._group._spiderfied = null;\n\t\t},\n\n\t\t_generatePointsCircle: function (count, centerPt) {\n\t\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\n\t\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\n\t\t\t\tangleStep = this._2PI / count,\n\t\t\t\tres = [],\n\t\t\t\ti, angle;\n\n\t\t\tlegLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.\n\n\t\t\tres.length = count;\n\n\t\t\tfor (i = 0; i < count; i++) { // Clockwise, like spiral.\n\t\t\t\tangle = this._circleStartAngle + i * angleStep;\n\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\n\t\t_generatePointsSpiral: function (count, centerPt) {\n\t\t\tvar spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,\n\t\t\t\tlegLength = spiderfyDistanceMultiplier * this._spiralLengthStart,\n\t\t\t\tseparation = spiderfyDistanceMultiplier * this._spiralFootSeparation,\n\t\t\t\tlengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,\n\t\t\t\tangle = 0,\n\t\t\t\tres = [],\n\t\t\t\ti;\n\n\t\t\tres.length = count;\n\n\t\t\t// Higher index, closer position to cluster center.\n\t\t\tfor (i = count; i >= 0; i--) {\n\t\t\t\t// Skip the first position, so that we are already farther from center and we avoid\n\t\t\t\t// being under the default cluster icon (especially important for Circle Markers).\n\t\t\t\tif (i < count) {\n\t\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t\t}\n\t\t\t\tangle += separation / legLength + i * 0.0005;\n\t\t\t\tlegLength += lengthFactor / angle;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tm, i;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tfg.removeLayer(m);\n\n\t\t\t\tif (m._preSpiderfyLatlng) {\n\t\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t\t}\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup._spiderfied = null;\n\t\t}\n\t});\n\n\t//Non Animated versions of everything\n\tL.MarkerClusterNonAnimated = L.MarkerCluster.extend({\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tlegOptions = this._group.options.spiderLegPolylineOptions,\n\t\t\t\ti, m, leg, newPos;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([this._latlng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Now add the marker.\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\t\t}\n\n\t\t\t\tfg.addLayer(m);\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup.fire('spiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t},\n\n\t\t_animationUnspiderfy: function () {\n\t\t\tthis._noanimationUnspiderfy();\n\t\t}\n\t});\n\n\t//Animated versions here\n\tL.MarkerCluster.include({\n\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerLatLng = this._latlng,\n\t\t\t\tthisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tlegOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.\n\t\t\t\tfinalLegOpacity = legOptions.opacity,\n\t\t\t\ti, m, leg, legPath, legLength, newPos;\n\n\t\t\tif (finalLegOpacity === undefined) {\n\t\t\t\tfinalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;\n\t\t\t}\n\n\t\t\tif (svg) {\n\t\t\t\t// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.\n\t\t\t\tlegOptions.opacity = 0;\n\n\t\t\t\t// Add the class for CSS transitions.\n\t\t\t\tlegOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';\n\t\t\t} else {\n\t\t\t\t// Make sure we have a defined opacity.\n\t\t\t\tlegOptions.opacity = finalLegOpacity;\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Add markers and spider legs to map, hidden at our center point.\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([thisLayerLatLng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/\n\t\t\t\t// In our case the transition property is declared in the CSS file.\n\t\t\t\tif (svg) {\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.\n\t\t\t\t\tlegPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t}\n\n\t\t\t\t// If it is a marker, add it now and we'll animate it out\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Vectors just get immediately added\n\t\t\t\tfg.addLayer(m);\n\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._forceLayout();\n\t\t\tgroup._animationStart();\n\n\t\t\t// Reveal markers and spider legs.\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Move marker to new position\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\t\n\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\tm.clusterShow();\n\t\t\t\t}\n\n\t\t\t\t// Animate leg (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegPath.style.strokeDashoffset = 0;\n\t\t\t\t\t//legPath.style.strokeOpacity = finalLegOpacity;\n\t\t\t\t\tleg.setStyle({opacity: finalLegOpacity});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('spiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t},\n\n\t\t_animationUnspiderfy: function (zoomDetails) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tm, i, leg, legPath, legLength, nonAnimatable;\n\n\t\t\tgroup._ignoreMove = true;\n\t\t\tgroup._animationStart();\n\n\t\t\t//Make us visible and bring the child markers back in\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Marker was added to us after we were spiderfied\n\t\t\t\tif (!m._preSpiderfyLatlng) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\n\t\t\t\tm.closePopup();\n\n\t\t\t\t//Fix up the location to the real one\n\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\tdelete m._preSpiderfyLatlng;\n\n\t\t\t\t//Hack override the location to be our center\n\t\t\t\tnonAnimatable = true;\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (nonAnimatable) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t}\n\n\t\t\t\t// Animate the spider leg back in (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1;\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t\tleg.setStyle({opacity: 0});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\n\t\t\t\tvar stillThereChildCount = 0;\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\t\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\t\tstillThereChildCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stillThereChildCount > 1) {\n\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t}\n\t});\n\n\n\tL.MarkerClusterGroup.include({\n\t\t//The MarkerCluster currently spiderfied (if any)\n\t\t_spiderfied: null,\n\n\t\tunspiderfy: function () {\n\t\t\tthis._unspiderfy.apply(this, arguments);\n\t\t},\n\n\t\t_spiderfierOnAdd: function () {\n\t\t\tthis._map.on('click', this._unspiderfyWrapper, this);\n\n\t\t\tif (this._map.options.zoomAnimation) {\n\t\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\t}\n\t\t\t//Browsers without zoomAnimation or a big zoom don't fire zoomstart\n\t\t\tthis._map.on('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tthis._map.getRenderer(this);\n\t\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\n\t\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n\t\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n\t\t\t}\n\t\t},\n\n\t\t_spiderfierOnRemove: function () {\n\t\t\tthis._map.off('click', this._unspiderfyWrapper, this);\n\t\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._map.off('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\t//Ensure that markers are back where they should be\n\t\t\t// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane\n\t\t\tthis._noanimationUnspiderfy();\n\t\t},\n\n\t\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n\t\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\n\t\t_unspiderfyZoomStart: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t},\n\n\t\t_unspiderfyZoomAnim: function (zoomDetails) {\n\t\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n\t\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._unspiderfy(zoomDetails);\n\t\t},\n\n\t\t_unspiderfyWrapper: function () {\n\t\t\t/// <summary>_unspiderfy but passes no arguments</summary>\n\t\t\tthis._unspiderfy();\n\t\t},\n\n\t\t_unspiderfy: function (zoomDetails) {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\n\t\t\t}\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied._noanimationUnspiderfy();\n\t\t\t}\n\t\t},\n\n\t\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n\t\t_unspiderfyLayer: function (layer) {\n\t\t\tif (layer._spiderLeg) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\n\t\t\t\tif (layer.setZIndexOffset) {\n\t\t\t\t\tlayer.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tthis._map.removeLayer(layer._spiderLeg);\n\t\t\t\tdelete layer._spiderLeg;\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing\n\t * markers' icon options and refreshing their icon and their parent clusters\n\t * accordingly (case where their iconCreateFunction uses data of childMarkers\n\t * to make up the cluster icon).\n\t */\n\n\n\tL.MarkerClusterGroup.include({\n\t\t/**\n\t\t * Updates the icon of all clusters which are parents of the given marker(s).\n\t\t * In singleMarkerMode, also updates the given marker(s) icon.\n\t\t * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\n\t\t * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\n\t\t * clusters need to be updated. If not provided, retrieves all child markers of this.\n\t\t * @returns {L.MarkerClusterGroup}\n\t\t */\n\t\trefreshClusters: function (layers) {\n\t\t\tif (!layers) {\n\t\t\t\tlayers = this._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.MarkerClusterGroup) {\n\t\t\t\tlayers = layers._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.LayerGroup) {\n\t\t\t\tlayers = layers._layers;\n\t\t\t} else if (layers instanceof L.MarkerCluster) {\n\t\t\t\tlayers = layers.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.Marker) {\n\t\t\t\tlayers = [layers];\n\t\t\t} // else: must be an Array(L.Marker)|Map(L.Marker)\n\t\t\tthis._flagParentsIconsNeedUpdate(layers);\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t// In case of singleMarkerMode, also re-draw the markers.\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._refreshSingleMarkerModeMarkers(layers);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Simply flags all parent clusters of the given markers as having a \"dirty\" icon.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_flagParentsIconsNeedUpdate: function (layers) {\n\t\t\tvar id, parent;\n\n\t\t\t// Assumes layers is an Array or an Object whose prototype is non-enumerable.\n\t\t\tfor (id in layers) {\n\t\t\t\t// Flag parent clusters' icon as \"dirty\", all the way up.\n\t\t\t\t// Dumb process that flags multiple times upper parents, but still\n\t\t\t\t// much more efficient than trying to be smart and make short lists,\n\t\t\t\t// at least in the case of a hierarchy following a power law:\n\t\t\t\t// http://jsperf.com/flag-nodes-in-power-hierarchy/2\n\t\t\t\tparent = layers[id].__parent;\n\t\t\t\twhile (parent) {\n\t\t\t\t\tparent._iconNeedsUpdate = true;\n\t\t\t\t\tparent = parent.__parent;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Re-draws the icon of the supplied markers.\n\t\t * To be used in singleMarkerMode only.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_refreshSingleMarkerModeMarkers: function (layers) {\n\t\t\tvar id, layer;\n\n\t\t\tfor (id in layers) {\n\t\t\t\tlayer = layers[id];\n\n\t\t\t\t// Make sure we do not override markers that do not belong to THIS group.\n\t\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\t\t// Need to re-create the icon first, then re-draw the marker.\n\t\t\t\t\tlayer.setIcon(this._overrideMarkerIcon(layer));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tL.Marker.include({\n\t\t/**\n\t\t * Updates the given options in the marker's icon and refreshes the marker.\n\t\t * @param options map object of icon options.\n\t\t * @param directlyRefreshClusters boolean (optional) true to trigger\n\t\t * MCG.refreshClustersOf() right away with this single marker.\n\t\t * @returns {L.Marker}\n\t\t */\n\t\trefreshIconOptions: function (options, directlyRefreshClusters) {\n\t\t\tvar icon = this.options.icon;\n\n\t\t\tL.setOptions(icon, options);\n\n\t\t\tthis.setIcon(icon);\n\n\t\t\t// Shortcut to refresh the associated MCG clusters right away.\n\t\t\t// To be used when refreshing a single marker.\n\t\t\t// Otherwise, better use MCG.refreshClusters() once at the end with\n\t\t\t// the list of modified markers.\n\t\t\tif (directlyRefreshClusters && this.__parent) {\n\t\t\t\tthis.__parent._group.refreshClusters(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\texports.MarkerClusterGroup = MarkerClusterGroup;\n\texports.MarkerCluster = MarkerCluster;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=leaflet.markercluster-src.js.map\n","interface Utils {\n    strNumFormat(s: string | number, iLen: number, sFillChar: string | null): string;\n    strZeroFormat(s: string | number, iLen: number): string;\n}\n\nconst Utils: Utils = {\n    strNumFormat(s: string | number, iLen: number, sFillChar: string | null = \" \"): string {\n        let str = String(s);\n        for (let i = str.length; i < iLen; i += 1) {\n            str = sFillChar + str;\n        }\n        return str;\n    },\n    strZeroFormat(s: string | number, iLen: number): string {\n        return Utils.strNumFormat(s, iLen, \"0\");\n    }\n};\n\nexport default class LatLng {\n    private lat: number;\n    private lng: number;\n    private format?: string;\n    private comment?: string;\n    private error?: string;\n\n    constructor(lat?: number | string, lng?: number | string) {\n        this.lat = 0;\n        this.lng = 0;\n        if (lat !== undefined && lng !== undefined) {\n            this.init(lat, lng);\n        }\n    }\n\n    private init(lat: number | string, lng: number | string): void {\n        this.setLatLng(lat, lng);\n    }\n\n    static toRadians(deg: number): number {\n        return deg * Math.PI / 180;\n    }\n\n    static toDegrees(rad: number): number {\n        return rad * 180 / Math.PI;\n    }\n\n    clone(): LatLng {\n        const clone = new LatLng();\n        Object.assign(clone, this);\n        return clone;\n    }\n\n    public getLat(): number {\n        return this.lat;\n    }\n\n    public getLng(): number {\n        return this.lng;\n    }\n\n    setLatLng(lat: number | string, lng: number | string): this {\n        this.lat = Number(lat);\n        this.lng = Number(lng);\n        return this;\n    }\n\n    getComment(): string {\n        return this.comment ?? \"\";\n    }\n\n    setComment(comment: string): this {\n        this.comment = comment;\n        return this;\n    }\n\n    getFormat(): string | undefined {\n        return this.format;\n    }\n\n    setFormat(format: string): this {\n        this.format = format;\n        return this;\n    }\n\n    getError(): string | undefined {\n        return this.error;\n    }\n\n    setError(error: string): this {\n        this.error = error;\n        return this;\n    }\n\n    toString(): string {\n        return Object.values(this).join(\",\");\n    }\n\n    distanceTo(point: LatLng): number {\n        const radius = 6371e3;\n        const phi1 = LatLng.toRadians(this.lat);\n        const lambda1 = LatLng.toRadians(this.lng);\n        const phi2 = LatLng.toRadians(point.lat);\n        const lambda2 = LatLng.toRadians(point.lng);\n        const deltaPhi = phi2 - phi1;\n        const deltaLambda = lambda2 - lambda1;\n\n        const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n            Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n        return radius * c;\n    }\n\n    bearingTo(point: LatLng): number {\n        const phi1 = LatLng.toRadians(this.lat);\n        const phi2 = LatLng.toRadians(point.lat);\n        const deltaLambda = LatLng.toRadians(point.lng - this.lng);\n\n        const y = Math.sin(deltaLambda) * Math.cos(phi2);\n        const x = Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(deltaLambda);\n        const theta = Math.atan2(y, x);\n\n        return (LatLng.toDegrees(theta) + 360) % 360;\n    }\n\n    destinationPoint(distance: number, bearing: number): LatLng {\n        const radius = 6371000;\n        const delta = Number(distance) / radius;\n        const theta = LatLng.toRadians(Number(bearing));\n\n        const phi1 = LatLng.toRadians(this.lat);\n        const lambda1 = LatLng.toRadians(this.lng);\n\n        const sinPhi1 = Math.sin(phi1);\n        const cosPhi1 = Math.cos(phi1);\n        const sinDelta = Math.sin(delta);\n        const cosDelta = Math.cos(delta);\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n\n        const sinPhi2 = sinPhi1 * cosDelta + cosPhi1 * sinDelta * cosTheta;\n        const phi2 = Math.asin(sinPhi2);\n        const y = sinTheta * sinDelta * cosPhi1;\n        const x = cosDelta - sinPhi1 * sinPhi2;\n        const lambda2 = lambda1 + Math.atan2(y, x);\n\n        return new LatLng(\n            LatLng.toDegrees(phi2),\n            (LatLng.toDegrees(lambda2) + 540) % 360 - 180\n        );\n    }\n\n    intersection(p1: LatLng, bearing1: number, p2: LatLng, bearing2: number): LatLng {\n        // see http://www.edwilliams.org/avform.htm#Intersection (former: http://williams.best.vwh.net/avform.htm#Intersection)\n        const phi1 = LatLng.toRadians(p1.lat);\n        const lambda1 = LatLng.toRadians(p1.lng);\n        const phi2 = LatLng.toRadians(p2.lat);\n        const lambda2 = LatLng.toRadians(p2.lng);\n        const theta13 = LatLng.toRadians(Number(bearing1));\n        const theta23 = LatLng.toRadians(Number(bearing2));\n        const deltaphi = phi2 - phi1;\n        const deltalambda = lambda2 - lambda1;\n\n        const delta12 = 2 * Math.asin(Math.sqrt(Math.sin(deltaphi / 2) * Math.sin(deltaphi / 2)\n            + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltalambda / 2) * Math.sin(deltalambda / 2))); // distance\n\n        if (delta12 === 0) {\n            return new LatLng(0, 0).setError(\"intersection distance=0\");\n        }\n\n        // initial/final bearings between points\n        const cosThetaa = (Math.sin(phi2) - Math.sin(phi1) * Math.cos(delta12)) / (Math.sin(delta12) * Math.cos(phi1));\n        const cosThetab = (Math.sin(phi1) - Math.sin(phi2) * Math.cos(delta12)) / (Math.sin(delta12) * Math.cos(phi2));\n        const thetaa = Math.acos(Math.min(Math.max(cosThetaa, -1), 1)); // protect against rounding errors\n        const thetab = Math.acos(Math.min(Math.max(cosThetab, -1), 1)); // protect against rounding errors\n\n        const theta12 = Math.sin(lambda2 - lambda1) > 0 ? thetaa : 2 * Math.PI - thetaa;\n        const theta21 = Math.sin(lambda2 - lambda1) > 0 ? 2 * Math.PI - thetab : thetab;\n\n        const alpha1 = (theta13 - theta12 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 2-1-3\n        const alpha2 = (theta21 - theta23 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 1-2-3\n\n        if (Math.sin(alpha1) === 0 && Math.sin(alpha2) === 0) {\n            return new LatLng(0, 0).setError(\"infinite intersections\");\n        }\n        if (Math.sin(alpha1) * Math.sin(alpha2) < 0) {\n            return new LatLng(0, 0).setError(\"ambiguous intersection\");\n        }\n\n        const alpha3 = Math.acos(-Math.cos(alpha1) * Math.cos(alpha2) + Math.sin(alpha1) * Math.sin(alpha2) * Math.cos(delta12));\n        const delta13 = Math.atan2(Math.sin(delta12) * Math.sin(alpha1) * Math.sin(alpha2), Math.cos(alpha2) + Math.cos(alpha1) * Math.cos(alpha3));\n        const phi3 = Math.asin(Math.sin(phi1) * Math.cos(delta13) + Math.cos(phi1) * Math.sin(delta13) * Math.cos(theta13));\n        const deltalambda13 = Math.atan2(Math.sin(theta13) * Math.sin(delta13) * Math.cos(phi1), Math.cos(delta13) - Math.sin(phi1) * Math.sin(phi3));\n        const lambda3 = lambda1 + deltalambda13;\n\n        return new LatLng(LatLng.toDegrees(phi3), (LatLng.toDegrees(lambda3) + 540) % 360 - 180); // normalise to 180..+180\n    }\n\n    parse(coord: string): this {\n        let lat = 0;\n        let lng = 0;\n        let sFormat = \"\";\n\n        function dmm2position() {\n            const aParts = coord.match(/^\\s*(N|S)\\s*(\\d+)\\s*[ ]\\s*(\\d+\\.\\d+)\\s*(E|W)\\s*(\\d+)\\s*[ ]\\s*(\\d+\\.\\d+)/); // dmm\n            if (aParts && aParts.length === 7) {\n                lat = parseInt(aParts[2], 10) + parseFloat(aParts[3]) / 60;\n                lng = parseInt(aParts[5], 10) + parseFloat(aParts[6]) / 60;\n                if (aParts[1] === \"S\") {\n                    lat = -lat;\n                }\n                if (aParts[4] === \"W\") {\n                    lng = -lng;\n                }\n                sFormat = \"dmm\";\n                return true;\n            }\n            return false;\n        }\n\n        function dms2position() {\n            const aParts = coord.match(/^\\s*(N|S)\\s*(\\d+)\\s*[ ]\\s*(\\d+)\\s*'\\s*(\\d+\\.?\\d*)\\s*\"\\s*(E|W)\\s*(\\d+)\\s*[ ]\\s*(\\d+)\\s*'\\s*(\\d+\\.?\\d*)\\s*\"/);\n            if (aParts && aParts.length === 9) {\n                lat = parseInt(aParts[2], 10) + parseFloat(aParts[3]) / 60 + parseFloat(aParts[4]) / 3600;\n                lng = parseInt(aParts[6], 10) + parseFloat(aParts[7]) / 60 + parseFloat(aParts[8]) / 3600;\n                if (aParts[1] === \"S\") {\n                    lat = -lat;\n                }\n                if (aParts[5] === \"W\") {\n                    lng = -lng;\n                }\n                sFormat = \"dms\";\n                return true;\n            }\n            return false;\n        }\n\n        function dd2position() {\n            const aParts = coord.match(/^\\s*(N|S)\\s*(\\d+\\.\\d+)\\s*[ ]\\s*(E|W)\\s*(\\d+\\.\\d+)\\s*?/);\n            if (aParts && aParts.length === 5) {\n                lat = parseFloat(aParts[2]);\n                lng = parseFloat(aParts[4]);\n                if (aParts[1] === \"S\") {\n                    lat = -lat;\n                }\n                if (aParts[3] === \"W\") {\n                    lng = -lng;\n                }\n                sFormat = \"dd\";\n                return true;\n            }\n            return false;\n        }\n\n        const iCommentIndex = coord.indexOf(\"!\");\n        if (iCommentIndex >= 0) {\n            this.comment = coord.substr(iCommentIndex + 1);\n            coord = coord.substr(0, iCommentIndex);\n        } else if (this.comment !== undefined) { // comment was set?\n            delete this.comment;\n        }\n\n        const bParseOk = dmm2position() || dms2position() || dd2position();\n        this.lat = lat;\n        this.lng = lng;\n        if (sFormat) {\n            this.format = sFormat + ((this.comment) ? \"c\" : \"\");\n        }\n        delete this.error;\n        if (!bParseOk && coord !== \"\") {\n            this.error = \"Cannot parse \" + coord;\n            console.warn(\"parse2position: Cannot parse '\" + coord + \"'\");\n        }\n        return this;\n    }\n\n    toFixed(digits: number): this {\n        this.lat = Number(Number(this.lat).toFixed(digits));\n        this.lng = Number(Number(this.lng).toFixed(digits));\n        return this;\n    }\n\n    toFormattedString(format?: string): string {\n        let sValue: string;\n        let sComment;\n\n        function position2dmm(position: LatLng) {\n            const lat = Math.abs(position.lat);\n            const lng = Math.abs(position.lng);\n            const latNS = (position.lat >= 0) ? \"N\" : \"S\";\n            const lngEW = (position.lng >= 0) ? \"E\" : \"W\";\n            const latdeg = Math.floor(lat);\n            const latmin = (lat - latdeg) * 60;\n            const lngdeg = Math.floor(lng);\n            const lngmin = (lng - lngdeg) * 60;\n\n            return latNS + \" \" + Utils.strZeroFormat(latdeg, 2) + \" \" + Utils.strZeroFormat(latmin.toFixed(3), 6) + \" \" + lngEW + \" \" + Utils.strZeroFormat(lngdeg, 3) + \" \" + Utils.strZeroFormat(lngmin.toFixed(3), 6);\n        }\n\n        function position2dms(position: LatLng) {\n            const lat = Math.abs(position.lat);\n            const lng = Math.abs(position.lng);\n            const latNS = (position.lat >= 0) ? \"N\" : \"S\";\n            const lngEW = (position.lng >= 0) ? \"E\" : \"W\";\n            const latdeg = Math.floor(lat);\n            const latmin = Math.floor((lat - latdeg) * 60);\n            const latsec = Math.round((lat - latdeg - latmin / 60) * 1000 * 3600) / 1000;\n            const lngdeg = Math.floor(lng);\n            const lngmin = Math.floor((lng - lngdeg) * 60);\n            const lngsec = Math.floor((lng - lngdeg - lngmin / 60) * 1000 * 3600) / 1000;\n\n            return latNS + \" \" + Utils.strZeroFormat(latdeg, 2) + \" \" + Utils.strZeroFormat(latmin, 2) + \"' \" + Utils.strZeroFormat(latsec.toFixed(2), 5) + \"\\\" \"\n                + lngEW + \" \" + Utils.strZeroFormat(lngdeg, 3) + \" \" + Utils.strZeroFormat(lngmin, 2) + \"' \" + Utils.strZeroFormat(lngsec.toFixed(2), 5) + \"\\\"\";\n        }\n\n        function position2dd(position: LatLng) {\n            let lat = position.lat;\n            let lng = position.lng;\n            const latNS = (lat >= 0) ? \"N\" : \"S\";\n            const lngEW = (lng >= 0) ? \"E\" : \"W\";\n\n            if (latNS === \"S\") {\n                lat = -lat;\n            }\n            if (lngEW === \"W\") {\n                lng = -lng;\n            }\n            const sDD = latNS + \" \" + Utils.strZeroFormat(lat.toFixed(5), 8) + \" \" + lngEW + \" \" + Utils.strZeroFormat(lng.toFixed(5), 9) + \"\";\n            return sDD;\n        }\n\n        format = format || this.format || \"dmm\";\n        if (format.charAt(format.length - 1) === \"c\") {\n            format = format.substr(0, format.length - 1);\n            sComment = this.getComment();\n        }\n        switch (format) {\n            case \"dmm\":\n                sValue = position2dmm(this);\n                break;\n            case \"dms\":\n                sValue = position2dms(this);\n                break;\n            case \"dd\":\n                sValue = position2dd(this);\n                break;\n            default:\n                sValue = \"\";\n                console.warn(\"position2string: Unknown format: \" + format);\n        }\n        if (sComment) {\n            sValue += \"!\" + sComment;\n        }\n        return sValue;\n    }\n}","// ScriptParser.ts - Parse calculation scripts\n\nimport LatLng from \"./LatLng\";\n\ntype Token = {\n\ttype: string;\n\tvalue: string;\n\tpos: number;\n};\n\ntype ParseNode = Token & {\n\tleft?: ParseNode;\n\tright?: ParseNode;\n\targs?: ParseNode[];\n\tname?: string;\n};\n\ntype ParseFunction = (node: ParseNode) => ParseNode;\n\ninterface SymbolType {\n\tnud?: ParseFunction // null denotative function\n\tlbp?: number // left binding power\n\tled?: ParseFunction // left denotative function\n}\n\nexport type ValueType = string | number | boolean;\n\nexport type ValueTypeWithNull = ValueType | null;\n\nexport type VariableAccessType = {\n\tvars: Record<string, ValueType>,\n\tget: (name: string) => ValueType,\n\tset: (name: string, value: ValueType) => void\n}\n\ntype OperatorFunctionType = (a: ValueTypeWithNull, b: ValueTypeWithNull) => ValueTypeWithNull;\n\ntype Functions = Record<string, (...args: ValueTypeWithNull[]) => ValueTypeWithNull>;\n\nconst functionList = \"_concat abs acos asin atan bearing cb center cls cos count cp ct d2r deg distance encode format goto ic instr int lc len mid mod pc project r2d rad replace reverse rot13 show skeleton sin sqrt sval tan uc val\".split(\" \");\nconst commandList = \"endif if stop then\".split(\" \");\nconst keywordsMap = [...functionList, ...commandList].reduce((acc, keyword) => {\n\tacc[keyword] = true;\n\treturn acc;\n}, {} as Record<string, boolean>);\n\nconst toRadians = (deg: number) => deg * Math.PI / 180;\nconst toDegrees = (rad: number) => rad * 180 / Math.PI;\n\n// needed for sval\nconst zFormat = (s: string, length: number) => {\n\ts = String(s);\n\tfor (let i = s.length; i < length; i += 1) {\n\t\ts = \"0\" + s;\n\t}\n\treturn s;\n};\n\n// needed for formatter\nconst numFormat = (s: string, format: string) => {\n\tif (format.indexOf(\".\") < 0) {\n\t\ts = Number(s).toFixed(0);\n\t\ts = zFormat(s, format.length);\n\t} else { // assume 000.00\n\t\tconst aFormat = format.split(\".\", 2);\n\t\ts = Number(s).toFixed(aFormat[1].length);\n\t\ts = zFormat(s, format.length);\n\t}\n\treturn s;\n};\n\nconst regExpEscape = (s: string) => {\n\treturn s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"); // (github.com/benjamingr/RegExp.escape), one / removed\n};\n\nexport default class ScriptParser {\n\toptions: { ignoreFuncCase?: boolean; ignoreVarCase?: boolean };\n\n\tconstructor(options?: { ignoreFuncCase?: boolean; ignoreVarCase?: boolean }) {\n\t\tthis.options = options || {};\n\t}\n\n\tstatic ErrorObject = class extends Error {\n\t\tvalue: string;\n\t\tpos: number;\n\t\tconstructor(message: string, value: string, pos: number) {\n\t\t\tsuper(`${message}: ${value} (pos: ${pos})`);\n\t\t\tthis.value = value;\n\t\t\tthis.pos = pos;\n\t\t\tthis.name = \"ScriptParserError\";\n\t\t}\n\t};\n\n\tlex(input: string): Token[] {\n\t\tconst isComment = (c: string) => /[#]/.test(c);\n\t\tconst isOperator = (c: string) => /[+\\-*/^%=<>()[\\],;]/.test(c);\n\t\tconst isDigit = (c: string) => /[0-9]/.test(c);\n\t\tconst isWhiteSpace = (c: string) => /\\s/.test(c);\n\t\tconst isQuotes = (c: string) => /[\"]/.test(c);\n\t\tconst isNotQuotes = (c: string) => c !== \"\" && !isQuotes(c);\n\t\tconst isApostrophe = (c: string) => /[']/.test(c);\n\t\tconst isNotApostrophe = (c: string) => c !== \"\" && !isApostrophe(c);\n\t\tconst isIdentifier = (c: string) => c !== \"\" && /[$\\w]/.test(c);\n\t\tconst isFormatter = (c: string) => /[:]/.test(c);\n\t\tconst isNotFormatter = (c: string) => c !== \"\" && /[0#.]/.test(c);\n\t\tconst isNotNewLine = (c: string) => c !== \"\" && c !== \"\\n\";\n\n\t\tconst aTokens: Token[] = [];\n\t\tlet sToken: string;\n\t\tlet sChar: string;\n\t\tlet iStartPos: number;\n\t\tlet iIndex = 0;\n\n\t\tconst advance = () => {\n\t\t\tiIndex += 1;\n\t\t\treturn input.charAt(iIndex);\n\t\t};\n\t\tconst advanceWhile = (fn: (c: string) => boolean) => {\n\t\t\tlet sToken2 = \"\";\n\t\t\tdo {\n\t\t\t\tsToken2 += sChar;\n\t\t\t\tsChar = advance();\n\t\t\t} while (fn(sChar));\n\t\t\treturn sToken2;\n\t\t};\n\t\tconst advanceWhileEscape = (fn: (c: string) => boolean) => {\n\t\t\tlet sToken2 = \"\";\n\t\t\tdo {\n\t\t\t\tif (sChar === \"\\\\\") {\n\t\t\t\t\tsChar = advance();\n\t\t\t\t\tif (sChar === \"n\") {\n\t\t\t\t\t\tsChar = \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsToken2 += sChar;\n\t\t\t\tsChar = advance();\n\t\t\t} while (fn(sChar));\n\t\t\treturn sToken2;\n\t\t};\n\t\tconst addToken = (type: string, value: string, iPos: number) => {\n\t\t\taTokens.push({ type, value, pos: iPos });\n\t\t};\n\n\t\twhile (iIndex < input.length) {\n\t\t\tiStartPos = iIndex;\n\t\t\tsChar = input.charAt(iIndex);\n\t\t\tif (isWhiteSpace(sChar)) {\n\t\t\t\tsChar = advance();\n\t\t\t} else if (isComment(sChar)) {\n\t\t\t\tadvanceWhile(isNotNewLine);\n\t\t\t} else if (isOperator(sChar)) {\n\t\t\t\tlet op = sChar;\n\t\t\t\tconst nextChar = input.charAt(iIndex + 1);\n\t\t\t\tif ((sChar === '<' || sChar === '>') && nextChar === '=') {\n\t\t\t\t\top += nextChar;\n\t\t\t\t\tadvance();\n\t\t\t\t} else if (sChar === '<' && nextChar === '>') {\n\t\t\t\t\top += nextChar;\n\t\t\t\t\tadvance();\n\t\t\t\t}\n\t\t\t\taddToken(op, \"\", iStartPos);\n\t\t\t\tsChar = advance();\n\t\t\t} else if (isDigit(sChar)) {\n\t\t\t\tsToken = advanceWhile(isDigit);\n\t\t\t\tif (sChar === \".\") {\n\t\t\t\t\tsToken += advanceWhile(isDigit);\n\t\t\t\t}\n\t\t\t\tconst numToken = parseFloat(sToken);\n\t\t\t\tif (!isFinite(numToken)) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Number is too large or too small\", sToken, iStartPos);\n\t\t\t\t}\n\t\t\t\taddToken(\"number\", sToken, iStartPos);\n\t\t\t} else if (isQuotes(sChar)) {\n\t\t\t\tsChar = \"\";\n\t\t\t\tsToken = advanceWhileEscape(isNotQuotes);\n\t\t\t\taddToken(\"string\", sToken, iStartPos + 1);\n\t\t\t\tif (!isQuotes(sChar)) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unterminated string\", sToken, iStartPos + 1);\n\t\t\t\t}\n\t\t\t\tsChar = advance();\n\t\t\t} else if (isApostrophe(sChar)) {\n\t\t\t\tsChar = \"\";\n\t\t\t\tsToken = advanceWhile(isNotApostrophe);\n\t\t\t\taddToken(\"string\", sToken, iStartPos + 1);\n\t\t\t\tif (!isApostrophe(sChar)) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unterminated string\", sToken, iStartPos + 1);\n\t\t\t\t}\n\t\t\t\tsChar = advance();\n\t\t\t} else if (isIdentifier(sChar)) {\n\t\t\t\tsToken = advanceWhile(isIdentifier);\n\t\t\t\tif (keywordsMap[sToken.toLowerCase()]) {\n\t\t\t\t\taddToken(sToken.toLowerCase(), \"\", iStartPos);\n\t\t\t\t} else {\n\t\t\t\t\taddToken(\"identifier\", sToken, iStartPos);\n\t\t\t\t}\n\t\t\t} else if (isFormatter(sChar)) {\n\t\t\t\tsChar = \"\";\n\t\t\t\tsToken = advanceWhile(isNotFormatter);\n\t\t\t\taddToken(\"formatter\", sToken, iStartPos);\n\t\t\t\tif (!isFormatter(sChar)) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unterminated formatter\", sToken, iStartPos + 1);\n\t\t\t\t}\n\t\t\t\tsChar = advance();\n\t\t\t} else {\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unrecognized token\", sChar, iStartPos);\n\t\t\t}\n\t\t}\n\t\taddToken(\"(end)\", \"\", iIndex);\n\t\treturn aTokens;\n\t}\n\n\tparse(tokens: Token[]): ParseNode[] {\n\t\tconst symbols: Record<string, SymbolType> = {};\n\t\tlet index = 0;\n\t\tconst parseTree: ParseNode[] = [];\n\n\t\tconst fnNode = (node: ParseNode) => node;\n\n\t\tconst symbol = (id: string, nud?: ParseFunction, lbp?: number, led?: ParseFunction) => {\n\t\t\tlet sym = symbols[id];\n\t\t\tif (!sym) {\n\t\t\t\tsymbols[id] = {};\n\t\t\t\tsym = symbols[id];\n\t\t\t}\n\t\t\tif (nud) {\n\t\t\t\tsym.nud = nud;\n\t\t\t}\n\t\t\tif (lbp) {\n\t\t\t\tsym.lbp = lbp;\n\t\t\t}\n\t\t\tif (led) {\n\t\t\t\tsym.led = led;\n\t\t\t}\n\t\t};\n\n\t\tconst interpretToken = (t: Token): ParseNode => {\n\t\t\tif (!t) {\n\t\t\t\t// return null;\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"No token\", \"\", 0);\n\t\t\t}\n\t\t\tconst parseToken = t as ParseNode; // we get a lex token and reuse it as parseTree token\n\t\t\treturn parseToken;\n\t\t};\n\n\t\tconst token = () => interpretToken(tokens[index]);\n\n\t\tconst advance = () => {\n\t\t\tindex += 1;\n\t\t\treturn token();\n\t\t};\n\n\t\tconst expression = (rbp: number): ParseNode => {\n\t\t\tlet t = token();\n\t\t\tlet s = symbols[t.type];\n\n\t\t\t// if (Utils.debug > 3) {\n\t\t\t//     Utils.console.debug(\"parse: expression rbp=\" + rbp + \" type=\" + t.type + \" t=%o\", t);\n\t\t\t// }\n\t\t\tadvance();\n\t\t\tif (!s.nud) {\n\t\t\t\tif (t.type === \"(end)\") {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unexpected end of file\", \"\", t.pos);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unexpected token (nud)\", t.type, t.pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet left = s.nud(t);\n\n\t\t\tt = token();\n\t\t\ts = symbols[t.type];\n\t\t\twhile (rbp < (s.lbp || 0)) {\n\t\t\t\tt = token();\n\t\t\t\tadvance();\n\t\t\t\tif (!s.led) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unexpected token\", t.type, tokens[index].pos);\n\t\t\t\t}\n\t\t\t\tleft = s.led(left);\n\t\t\t\tt = token();\n\t\t\t\ts = symbols[t.type];\n\t\t\t}\n\t\t\treturn left;\n\t\t};\n\n\t\tconst infix = (id: string, lbp: number, rbp?: number, led?: ParseFunction) => {\n\t\t\trbp = rbp || lbp;\n\t\t\tsymbol(id, undefined, lbp, led || function (left: ParseNode) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: id,\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: expression(rbp) // rbp!\n\t\t\t\t\t//value: \"\",\n\t\t\t\t\t//pos: 0\n\t\t\t\t} as ParseNode;\n\t\t\t});\n\t\t};\n\t\tconst prefix = (id: string, rbp: number) => {\n\t\t\tsymbol(id, () => {\n\t\t\t\treturn {\n\t\t\t\t\ttype: id,\n\t\t\t\t\tright: expression(rbp)\n\t\t\t\t\t//value: \"\",\n\t\t\t\t\t//pos: 0\n\t\t\t\t} as ParseNode;\n\t\t\t});\n\t\t};\n\n\t\tsymbol(\",\");\n\t\tsymbol(\")\");\n\t\tsymbol(\"]\");\n\t\tsymbol(\"(end)\");\n\t\tsymbol(\";\");\n\n\t\tsymbol(\"number\", fnNode);\n\t\tsymbol(\"string\", fnNode);\n\t\tsymbol(\"identifier\", (node: ParseNode) => {\n\t\t\treturn node;\n\t\t});\n\n\n\t\tfunction createFunctionCall(node: ParseNode) {\n\t\t\tif (token().type === \"(\") {\n\t\t\t\tconst parseIndex = index;\n\t\t\t\tconst args: ParseNode[] = [];\n\n\t\t\t\tif (tokens[index + 1].type === \")\") {\n\t\t\t\t\tadvance();\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tadvance();\n\t\t\t\t\t\targs.push(expression(2));\n\t\t\t\t\t} while (token().type === \",\");\n\t\t\t\t\tif (token().type !== \")\") {\n\t\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Expected closing parenthesis for function\", String(tokens[parseIndex - 1].type), tokens[parseIndex].pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadvance();\n\t\t\t\treturn {\n\t\t\t\t\ttype: node.type,\n\t\t\t\t\targs: args,\n\t\t\t\t\tname: \"\",\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tpos: tokens[parseIndex - 1].pos\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tfunction generateKeywordSymbols() {\n\t\t\tfor (const key of functionList) {\n\t\t\t\tsymbol(key, createFunctionCall);\n\t\t\t}\n\t\t\tfor (const key of commandList) {\n\t\t\t\tsymbol(key, createFunctionCall);\n\t\t\t}\n\t\t}\n\n\t\tgenerateKeywordSymbols();\n\n\n\t\tsymbol(\"(\", () => {\n\t\t\tconst parseIndex = index;\n\t\t\tconst value = expression(2);\n\t\t\tif (token().type !== \")\") {\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"Expected closing parenthesis\", \")\", tokens[parseIndex].pos);\n\t\t\t}\n\t\t\tadvance();\n\t\t\treturn value;\n\t\t});\n\n\t\tsymbol(\"[\", function () {\n\t\t\tlet t = token();\n\t\t\tlet node: ParseNode;\n\t\t\tif (t.type === \"(end)\") {\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unexpected end of file\", \"\", t.pos);\n\t\t\t}\n\t\t\tif (tokens[index + 1].type === \"]\") {\n\t\t\t\tnode = expression(2);\n\t\t\t} else {\n\t\t\t\tconst parseIndex = index;\n\t\t\t\tconst args: ParseNode[] = [];\n\t\t\t\tdo {\n\t\t\t\t\targs.push(expression(2));\n\t\t\t\t\tt = token();\n\t\t\t\t} while (t.type !== \"]\" && t.type !== \"(end)\");\n\t\t\t\tif (t.type !== \"]\") {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Expected closing bracket\", \"]\", tokens[parseIndex].pos);\n\t\t\t\t}\n\t\t\t\tnode = {\n\t\t\t\t\ttype: \"_concat\",\n\t\t\t\t\targs: args,\n\t\t\t\t\tname: \"\", //\"concat\",\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tpos: tokens[parseIndex - 1].pos\n\t\t\t\t};\n\t\t\t}\n\t\t\tadvance();\n\t\t\treturn node;\n\t\t});\n\n\t\t// Add a flag to track if we're parsing an IF condition\n\t\tlet isInIfCondition = false;\n\n\t\tsymbol(\"if\", () => {\n\t\t\tisInIfCondition = true;\n\t\t\tconst condition = expression(0);\n\t\t\tisInIfCondition = false;\n\n\t\t\tif (token().type !== \"then\") {\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"Expected THEN\", \"\", token().pos);\n\t\t\t}\n\t\t\tadvance(); // consume THEN\n\n\t\t\tconst commands: ParseNode[] = [];\n\t\t\twhile (token().type !== \"endif\" && token().type !== \"(end)\") {\n\t\t\t\tcommands.push(expression(0));\n\t\t\t\tif (token().type === \";\") {\n\t\t\t\t\tadvance();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token().type !== \"endif\") {\n\t\t\t\tthrow new ScriptParser.ErrorObject(\"Expected ENDIF\", \"\", token().pos);\n\t\t\t}\n\t\t\tadvance(); // consume ENDIF\n\n\t\t\treturn {\n\t\t\t\ttype: \"if\",\n\t\t\t\tleft: condition,\n\t\t\t\targs: commands,\n\t\t\t\tpos: condition.pos,\n\t\t\t\tvalue: \"\"\n\t\t\t};\n\t\t});\n\n\t\tsymbol(\"formatter\", undefined, 3, (left: ParseNode) => {\n\t\t\tconst t = tokens[index - 1]; // formatter token\n\t\t\treturn {\n\t\t\t\ttype: \"formatter\",\n\t\t\t\tvalue: t.value,\n\t\t\t\tleft: left,\n\t\t\t\tpos: t.pos\n\t\t\t};\n\t\t});\n\n\t\tprefix(\"-\", 8);\n\t\tinfix(\"^\", 7, 6);\n\t\tinfix(\"*\", 5);\n\t\tinfix(\"/\", 5);\n\t\tinfix(\"%\", 5);\n\t\tinfix(\"+\", 4);\n\t\tinfix(\"-\", 4);\n\n\t\t// Comparison operators\n\t\tinfix(\"<\", 4);\n\t\tinfix(\">\", 4);\n\t\tinfix(\"<=\", 4);\n\t\tinfix(\">=\", 4);\n\t\tinfix(\"<>\", 4);\n\n\t\tinfix(\"=\", 3, 2, (left: ParseNode) => {\n\t\t\tlet node: ParseNode;\n\t\t\t// If in an IF statement context, treat as comparison\n\t\t\tif (left.type === \"identifier\" && !isInIfCondition) {\n\t\t\t\tnode = {\n\t\t\t\t\ttype: \"assign\",\n\t\t\t\t\tname: left.value,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tright: expression(0), // //TTT value: expression(2),\n\t\t\t\t\tpos: left.pos\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Otherwise treat as comparison\n\t\t\t\tnode = {\n\t\t\t\t\ttype: \"=\",\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: expression(2),\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tpos: left.pos\n\t\t\t\t};\n\t\t\t\t//node = tokens[index - 1];\n\t\t\t\t//throw new ScriptParser.ErrorObject(`Invalid lvalue ${left.type} at`, node.type, node.pos);\n\t\t\t}\n\t\t\treturn node;\n\t\t});\n\n\t\twhile (token().type !== \"(end)\") {\n\t\t\tparseTree.push(expression(0));\n\t\t}\n\t\treturn parseTree;\n\t}\n\n\tevaluate(parseTree: ParseNode[], variableAccess: VariableAccessType, functions: Functions): string {\n\t\tconst that = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\t\tconst operators: Record<string, OperatorFunctionType> = {\n\t\t\t\"+\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => Number(a) + Number(b),\n\t\t\t\"-\": (a: ValueTypeWithNull, b?: ValueTypeWithNull) => (b === null ? -Number(a) : Number(a) - Number(b)),\n\t\t\t\"*\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => Number(a) * Number(b), // (a: number, b: number)\n\t\t\t\"/\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => Number(a) / Number(b), // (a: number, b: number)\n\t\t\t\"%\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => Number(a) % Number(b),\n\t\t\t\"^\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => Math.pow(Number(a), Number(b)),\n\n\t\t\t\"=\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) === String(b),\n\t\t\t\"<>\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) !== String(b),\n\t\t\t\"<\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) < String(b),\n\t\t\t\">\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) > String(b),\n\t\t\t\"<=\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) <= String(b),\n\t\t\t\">=\": (a: ValueTypeWithNull, b: ValueTypeWithNull) => String(a) >= String(b)\n\t\t};\n\t\tconst mFunctions = functions;\n\n\t\tconst output: string[] = [];\n\n\t\tconst checkArgs = (name: string, aArgs: ValueTypeWithNull[], iPos: number) => {\n\t\t\tconst oFunction = mFunctions[name];\n\n\t\t\tif (oFunction.length !== aArgs.length) {\n\t\t\t\tconst optionalArgs = mFunctions[`${name}_optionalArgs`]?.();\n\t\t\t\tif (optionalArgs) {\n\t\t\t\t\tif (optionalArgs === Number.POSITIVE_INFINITY) { // varargs (needed for _concat)?\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst iMin = oFunction.length - Number(optionalArgs); // optionalArgs (instr)\n\t\t\t\t\tif (aArgs.length >= iMin && aArgs.length <= oFunction.length) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.warn(\"WARN: oFunction=\", String(oFunction));\n\t\t\t\tthrow new ScriptParser.ErrorObject(`Wrong number of arguments (${oFunction.length}, ${aArgs.length}) for function`, name, iPos);\n\t\t\t}\n\t\t};\n\n\t\tconst fnAdaptFunctionName = (sName: string) =>\n\t\t\tthat.options.ignoreFuncCase ? sName.toLowerCase() : sName;\n\n\t\tconst fnAdaptVariableName = (sName: string) =>\n\t\t\tthat.options.ignoreVarCase ? sName.toLowerCase() : sName;\n\n\t\tconst parseNode = (node: ParseNode): ValueTypeWithNull => {\n\t\t\tlet value: ValueTypeWithNull;\n\t\t\tlet sName: string;\n\t\t\tif (node.type === \"string\") {\n\t\t\t\tvalue = node.value; //as string\n\t\t\t} else if (node.type === \"number\") {\n\t\t\t\tvalue = parseFloat(node.value); //as string\n\t\t\t} else if (operators[node.type]) {\n\t\t\t\tif (node.left) {\n\t\t\t\t\tvalue = operators[node.type](parseNode(node.left), parseNode(node.right!));\n\t\t\t\t} else {\n\t\t\t\t\tvalue = operators[node.type](parseNode(node.right!), null);\n\t\t\t\t}\n\t\t\t} else if (node.type === \"identifier\") {\n\t\t\t\tsName = fnAdaptVariableName(node.value); //as string\n\t\t\t\tvalue = variableAccess.get(sName);\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\t//throw new ScriptParser.ErrorObject(\"Variable is undefined\", String(node.value), node.pos);\n\t\t\t\t\tconsole.log(`Variable is undefined: ${node.value} (pos ${node.pos})`);\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\t\t\t} else if (node.type === \"assign\") {\n\t\t\t\tvalue = parseNode(node.right!); //value = parseNode(node.value!);\n\t\t\t\tsName = fnAdaptVariableName(node.name!);\n\t\t\t\tif (value === null) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"value is null\", sName, node.pos); // should not occure\n\t\t\t\t}\n\t\t\t\tvariableAccess.set(sName, value);\n\t\t\t\tif (String(parseFloat(String(value))) !== String(value)) { //TTT tocheck!\n\t\t\t\t\tvalue = '\"' + value + '\"';\n\t\t\t\t}\n\t\t\t\tvalue = node.name + \"=\" + value;\n\t\t\t} else if (node.type === \"if\") {\n\t\t\t\tconst condition = parseNode(node.left!);\n\t\t\t\tif (condition) {\n\t\t\t\t\tconst results: string[] = [];\n\t\t\t\t\tfor (const cmd of node.args!) {\n\t\t\t\t\t\tconst result = parseNode(cmd);\n\t\t\t\t\t\tif (result === null) {\n\t\t\t\t\t\t\tif (cmd.type === \"cls\") {\n\t\t\t\t\t\t\t\toutput.length = 0;\n\t\t\t\t\t\t\t\tresults.length = 0;\n\t\t\t\t\t\t\t} else if (cmd.type === \"stop\") {\n\t\t\t\t\t\t\t\t//i = parseTree.length; // stop TODO\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (result !== \"\") {\n\t\t\t\t\t\t\tresults.push(String(result));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalue = results.join(\"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\t\t\t} else if (node.type === \"stop\") {\n\t\t\t\tvalue = null;\n\t\t\t} else if (keywordsMap[node.type]) { // \"if\" and \"stop\" are already handled\n\t\t\t\tconst aNodeArgs: ValueTypeWithNull[] = [];\n\t\t\t\tfor (let i = 0; i < node.args!.length; i += 1) {\n\t\t\t\t\taNodeArgs[i] = parseNode(node.args![i]);\n\t\t\t\t}\n\t\t\t\tsName = fnAdaptFunctionName(node.type);\n\t\t\t\tif (mFunctions[sName] === undefined) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Function is undefined\", sName, node.pos); // should not occur\n\t\t\t\t}\n\t\t\t\tcheckArgs(sName, aNodeArgs, node.pos);\n\t\t\t\tvalue = mFunctions[sName].apply(node, aNodeArgs);\n\t\t\t} else if (node.type === \"formatter\") {\n\t\t\t\tvalue = parseNode(node.left!);\n\t\t\t\tvalue = numFormat(String(value), node.value);\n\t\t\t} else {\n\t\t\t\tconsole.error(\"parseNode node=%o unknown type=\" + node.type, node);\n\t\t\t\tvalue = String(node); // eslint-disable-line @typescript-eslint/no-base-to-string\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\tfor (let i = 0; i < parseTree.length; i += 1) {\n\t\t\t// if (Utils.debug > 2) {\n\t\t\t//     Utils.console.debug(\"evaluate: parseTree i=%d, node=%o\", i, parseTree[i]);\n\t\t\t// }\n\t\t\tconst node = parseTree[i];\n\t\t\tconst result = parseNode(node);\n\t\t\tif (result === null) { // cls, stop on single line?\n\t\t\t\tif (node.type === \"cls\") {\n\t\t\t\t\toutput.length = 0;\n\t\t\t\t} else if (node.type === \"stop\") {\n\t\t\t\t\ti = parseTree.length; // stop\n\t\t\t\t}\n\t\t\t} else if (result !== \"\") {\n\t\t\t\toutput.push(String(result));\n\t\t\t}\n\t\t}\n\t\treturn output.join(\"\\n\");\n\t}\n\n\tcalculate(input: string, variableAccess: VariableAccessType): string {\n\t\tconst that = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\t\tconst mFunctions = {\n\t\t\t// _concat(s1, s2, ...) concatenate strings (called by operator [..] ); varargs\n\t\t\t_concat_optionalArgs: () => Number.POSITIVE_INFINITY,\n\t\t\t_concat: (...args: (string | number)[]) => args.join(\"\"),\n\n\t\t\t//\n\n\t\t\tabs: (x: number): number => Math.abs(x), //abs: Math.abs,\n\n\t\t\tacos: (x: number): number => toDegrees(Math.acos(x)),\n\n\t\t\tasin: (x: number): number => toDegrees(Math.asin(x)),\n\n\t\t\tatan: (x: number): number => toDegrees(Math.atan(x)),\n\n\t\t\t// bearing(w1, w2) bearing between w1 and w2 in degrees\n\t\t\tbearing: function (w1: string, w2: string) {\n\t\t\t\tconst pos1 = new LatLng().parse(w1);\n\t\t\t\tconst pos2 = new LatLng().parse(w2);\n\n\t\t\t\treturn pos1.bearingTo(pos2);\n\t\t\t},\n\n\t\t\t// cb(w1, angle1, w2, angle2) crossbearing\n\t\t\tcb: function (w1: string, angle1: number, w2: string, angle2: number) {\n\t\t\t\tconst pos1 = new LatLng().parse(w1);\n\t\t\t\tconst pos2 = new LatLng().parse(w2);\n\n\t\t\t\tconst pos3 = LatLng.prototype.intersection(pos1, angle1, pos2, angle2);\n\t\t\t\tconst err = pos3.getError();\n\t\t\t\tlet sValue = pos3.toFormattedString();\n\t\t\t\tif (err) {\n\t\t\t\t\tsValue += \"!error!\" + err;\n\t\t\t\t}\n\t\t\t\treturn sValue;\n\t\t\t},\n\n\t\t\t// center, zentrum\n\t\t\tcenter: () => {\n\t\t\t\tconsole.log(\"center() ignored.\");\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\tcls: () => null, // clear output trigger\n\n\t\t\tcos: (deg: number): number => Math.cos(toRadians(deg)),\n\n\t\t\t// count(s, s2) count individual characters from s2 in string s\n\t\t\tcount: function (s: string, s2: string) {\n\t\t\t\tlet sOut = \"\";\n\n\t\t\t\ts = String(s);\n\t\t\t\ts2 = String(s2);\n\t\t\t\tif (s2.length === 1) {\n\t\t\t\t\treturn mFunctions.countStr(s, s2);\n\t\t\t\t}\n\t\t\t\tconst aSearch = s2.split(\"\");\n\t\t\t\tfor (let i = 0; i < aSearch.length; i += 1) {\n\t\t\t\t\tconst sStr = aSearch[i];\n\t\t\t\t\tsOut += \" \" + sStr + \"=\" + mFunctions.countStr(s, sStr);\n\t\t\t\t}\n\t\t\t\treturn sOut.trim();\n\t\t\t\t// CacheWolf appends a space, we don't do that.\n\t\t\t},\n\n\t\t\t// countStr(s, c) Count number of occurrences of substring s2 in s //TTT\n\t\t\t// https://stackoverflow.com/questions/881085/count-the-number-of-occurrences-of-a-character-in-a-string-in-javascript\n\t\t\tcountStr: function (s: string, s2: string) {\n\t\t\t\treturn (String(s).match(new RegExp(s2, \"g\")) || []).length;\n\t\t\t},\n\n\t\t\t// cp, curpos TTT ??\n\n\t\t\t// ct (crosstotal)\n\t\t\tct: function (x: number) {\n\t\t\t\tconst sStr = String(x).replace(/[^\\d]/g, \"\");\n\t\t\t\tlet iSum = 0;\n\n\n\t\t\t\tfor (let i = 0; i < sStr.length; i += 1) {\n\t\t\t\t\tiSum += Number(sStr.charAt(i));\n\t\t\t\t}\n\t\t\t\treturn iSum;\n\t\t\t},\n\n\t\t\td2r: (deg: number) => toRadians(deg),\n\n\t\t\t// deg() switch do degrees mode (default, ignored, we always use degrees)\n\t\t\tdeg: () => {\n\t\t\t\tconsole.log(\"deg() ignored.\"); //TTT\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\t// distance(w1, w2) distance between w1 and w2 in meters\n\t\t\tdistance: function (w1: string, w2: string) {\n\t\t\t\tconst oPosition1 = new LatLng().parse(w1);\n\t\t\t\tconst oPosition2 = new LatLng().parse(w2);\n\n\t\t\t\tconst nValue = oPosition1.distanceTo(oPosition2);\n\t\t\t\treturn nValue;\n\t\t\t},\n\n\t\t\t// encode(s, m1, m2) encode s with character mapping m1 to m2\n\t\t\t// example rot13: sourceMap=\"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\" destinatonMap=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\t\t\t// https://stackoverflow.com/questions/617647/where-is-my-one-line-implementation-of-rot13-in-javascript-going-wrong\n\t\t\tencode: function (s: string, sourceMap: string, destinatonMap: string) {\n\t\t\t\tconst rSearch = new RegExp(\"[\" + sourceMap + \"]\", \"g\");\n\n\t\t\t\treturn s.replace(rSearch, function (c) {\n\t\t\t\t\treturn destinatonMap.charAt(\n\t\t\t\t\t\tsourceMap.indexOf(c)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// format(w1, fmt): format waypoint w1 with format \"\", \"dmm\", \"dms\", \"dd\", \"dmmc\", \"dmsc\", \"ddc\"\n\t\t\tformat: function (w1: string, format: string) {\n\t\t\t\tconst oPosition = new LatLng().parse(w1);\n\n\t\t\t\tconst sValue = oPosition.toFormattedString(format);\n\t\t\t\tif (!sValue) {\n\t\t\t\t\tthrow new ScriptParser.ErrorObject(\"Unknown format\", format, -1);\n\t\t\t\t}\n\t\t\t\treturn sValue;\n\t\t\t},\n\n\t\t\tgoto: (w1: string) => {\n\t\t\t\tconsole.log(`goto ${w1}: ignored.`);\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\t// ic(n) Ignore variable andd function case\n\t\t\tic_optionalArgs: () => 1, // optional args 1: mode\n\t\t\tic: function (mode?: string) {\n\t\t\t\tif (typeof mode === \"undefined\") { // no parameter, return status\n\t\t\t\t\treturn Boolean(that.options.ignoreVarCase);\n\t\t\t\t}\n\t\t\t\tthat.options.ignoreVarCase = Boolean(mode);\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\t// instr (indexOf with positions starting with 1), 'start' is optional\n\t\t\tinstr_optionalArgs: () => 1,\n\t\t\tinstr: function (s: string, search: string, start?: number) { // optional args 1: start\n\t\t\t\treturn String(s).indexOf(search, start ? start - 1 : 0) + 1;\n\t\t\t},\n\n\t\t\tint: Math.trunc,\n\n\t\t\t// lc, toLowerCase\n\t\t\tlc: (s: string) => String(s).toLowerCase(),\n\n\t\t\tlen: (s: string) => String(s).length,\n\n\t\t\t// mid(s, index, len?) substr with positions starting with 1\n\t\t\tmid_optionalArgs: () => 1,\n\t\t\tmid: function (s: string, start: number, length?: number) {\n\t\t\t\tif (typeof length === \"undefined\") {\n\t\t\t\t\treturn String(s).substring(start - 1);\n\t\t\t\t}\n\t\t\t\treturn String(s).substring(start - 1, start - 1 + length);\n\t\t\t},\n\n\t\t\t// mod: or should it be... https://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving\n\t\t\tmod: function (a: number, b: number) { return a % b; },\n\n\t\t\t// pc, pz, profilecenter, profilezentrum\n\t\t\tpc: () => {\n\t\t\t\tconsole.warn(\"pc ignored.\");\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\t// project(w1, bearing, distance) project from w1 bearing degrees and distance meters\n\t\t\tproject: function (w1: string, bearing: number, distance: number) {\n\t\t\t\tconst pos1 = new LatLng().parse(w1);\n\t\t\t\tconst pos2 = pos1.destinationPoint(distance, bearing); // order of arguments!\n\t\t\t\treturn pos2.toFormattedString();\n\t\t\t},\n\n\t\t\t// r2d, rad2deg\n\t\t\tr2d: (rad: number) => toDegrees(rad),\n\n\t\t\t// rad() switch do radians mode (not supported, we always use degrees)\n\t\t\trad: () => {\n\t\t\t\tconsole.warn(\"rad ignored.\");\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\t// replace(s, s1, r1): replace all occurrences of s1 in s by r1\n\t\t\treplace: function (s: string, search: string, replace: string) {\n\t\t\t\tconst escaped = regExpEscape(search);\n\t\t\t\tconst pattern = new RegExp(escaped, \"g\");\n\t\t\t\treturn String(s).replace(pattern, replace);\n\t\t\t},\n\n\t\t\treverse: function (s: string) {\n\t\t\t\treturn String(s).split(\"\").reverse().join(\"\");\n\t\t\t},\n\n\t\t\trot13: function (s: string) {\n\t\t\t\treturn String(s).replace(/[A-Za-z]/g, function (c) {\n\t\t\t\t\treturn String.fromCharCode(c.charCodeAt(0) + (c.toUpperCase() <= \"M\" ? 13 : -13));\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tshow: () => {\n\t\t\t\tconsole.warn(\"show ignored.\");\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\tsin: (deg: number): number => Math.sin(toRadians(deg)),\n\n\t\t\tskeleton: () => {\n\t\t\t\tconsole.warn(\"skeleton ignored.\");\n\t\t\t\treturn \"\";\n\t\t\t},\n\n\t\t\tsqrt: Math.sqrt,\n\n\t\t\t// sval (separate value) for A-Z, a-z: 01 02 03 ...\n\t\t\tsval: function (s: string) {\n\t\t\t\tconst iCodeBeforeA = \"a\".charCodeAt(0) - 1;\n\t\t\t\tlet sOut = \"\";\n\n\t\t\t\ts = String(s).toLowerCase().replace(/[^a-z]/g, \"\");\n\t\t\t\tfor (let i = 0; i < s.length; i += 1) {\n\t\t\t\t\tsOut += ((i > 0) ? \" \" : \"\") + zFormat(String(s.charCodeAt(i) - iCodeBeforeA), 2);\n\t\t\t\t}\n\t\t\t\treturn sOut;\n\t\t\t},\n\n\t\t\ttan: (deg: number): number => Math.tan(toRadians(deg)),\n\n\t\t\t// uc, touppercase, ucase\n\t\t\tuc: (s: string) => String(s).toUpperCase(),\n\n\t\t\t// val (value) for A-Z, a-z: 1-26\n\t\t\tval: function (s: string) {\n\t\t\t\tconst iCodeBeforeA = \"a\".charCodeAt(0) - 1;\n\t\t\t\tlet iSum = 0;\n\n\t\t\t\ts = String(s).toLowerCase();\n\t\t\t\tfor (let i = 0; i < s.length; i += 1) {\n\t\t\t\t\tlet iNumber = s.charCodeAt(i) - iCodeBeforeA;\n\t\t\t\t\tif ((iNumber < 0) || (iNumber > 26)) {\n\t\t\t\t\t\tiNumber = 0;\n\t\t\t\t\t}\n\t\t\t\t\tiSum += iNumber;\n\t\t\t\t}\n\t\t\t\treturn iSum;\n\t\t\t},\n\n\t\t\t// Not in Wolf Language:\n\t\t\t//log: Math.log,\n\t\t\t//exp: Math.exp,\n\t\t\t//max: Math.max,\n\t\t\t//min: Math.min,\n\t\t\t//random: Math.random,\n\t\t\t// gcd: greatest common divisor of a and b (Euclid)\n\t\t\t// fib: xth Fibonacci number\n\t\t\t// midpoint: Same as: project(w1, bearing(w1, w2), distance(w1, w2) / 2)\n\t\t\t// cti (crosstotal iterated)\n\t\t\t// vstr (value(s) to string, optional iShift) (new)\n\t\t\t// isequal a === b\n\t\t\t// getconst; PI, E\n\t\t\t// parse(s)\n\t\t\t// assert(a, b)\n\t\t}\n\n\t\tconst tokens = this.lex(input);\n\t\tconst parseTree = this.parse(tokens);\n\t\tconst output = this.evaluate(parseTree, variableAccess, mFunctions as Functions);\n\t\treturn output;\n\t}\n}\n\n// TODO:\n// - LatLng: use L.LatLon for internal pos?\n//","// ZipCrypto.ts\n// Implementation of traditional PKWARE ZipCrypto algorithm\n// Reference: https://pkwaredownloads.blob.core.windows.net/pkware-general/Documentation/APPNOTE-6.3.9.TXT (section 6.1)\n\n// Public interface for parts of Central Directory File Header needed for decryption\nexport interface CentralDirFileHeaderPart {\n    readonly flag: number // General purpose bit flag\n        // bit 0: encrypted; bit 6: strong encryption; bit 13: central directory encrypted\n    readonly modificationTime: number // File last modification time (DOS time)\n    readonly crc: number // CRC-32 of uncompressed data\n}\n\nexport class ZipCrypto {\n    // Make sure to use Math.imul for 32 bit unsigend! (https://matthewtolman.com/article/unsigned-integers-in-javascript)\n\n    private static createCrcTable(): Uint32Array {\n        const crcTable = new Uint32Array(256);\n        for (let i = 0; i < 256; i += 1) {\n            let c = i;\n            for (let j = 0; j < 8; j += 1) {\n                c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);\n            }\n            crcTable[i] = c >>> 0;\n        }\n        return crcTable;\n    }\n\n    private static crcTable?: Uint32Array = undefined;\n\n    private static crc32(crc: number, c: number) {\n        const crcTable = ZipCrypto.crcTable || (ZipCrypto.crcTable = ZipCrypto.createCrcTable());\n        return ((crc >>> 8) ^ crcTable[(crc ^ c) & 0xff]) >>> 0;\n    };\n\n    private static updateKeys(keys: number[], c: number): void {\n        keys[0] = ZipCrypto.crc32(keys[0], c);\n        keys[1] = (keys[1] + (keys[0] & 0xff)) >>> 0;\n        keys[1] = (Math.imul(keys[1], 134775813) >>> 0) + 1 >>> 0;\n        keys[2] = ZipCrypto.crc32(keys[2], (keys[1] >>> 24) & 0xff);\n    }\n\n    private static initKeys(password: string): number[] {\n        const keys = [0x12345678, 0x23456789, 0x34567890];\n        for (let i = 0; i < password.length; i += 1) {\n            ZipCrypto.updateKeys(keys, password.charCodeAt(i));\n        }\n        return keys;\n    }\n\n    private static decryptByte(keys: number[], c: number): number {\n        const temp = (keys[2] | 2) >>> 0;\n\n        const decrypted = c ^ ((Math.imul(temp, temp ^ 1) >>> 8) & 0xff);\n        ZipCrypto.updateKeys(keys, decrypted);\n        return decrypted;\n    }\n\n    //\n    // Public API\n    // \n    // Check if the file is encrypted\n    static isEncrypted(cdfh: CentralDirFileHeaderPart) {\n        return cdfh.flag & 1;\n    }\n\n    // Decrypt data with given password\n    static decrypt(data: Uint8Array, cdfh: CentralDirFileHeaderPart, password: string): Uint8Array {\n        const keys = ZipCrypto.initKeys(password);\n        const decryptedHeader = new Uint8Array(12);\n        for (let i = 0; i < 12; i += 1) {\n            const c = ZipCrypto.decryptByte(keys, data[i]);\n            decryptedHeader[i] = c;\n        }\n\n        let checkByte: number;\n        if ((cdfh.flag & 0x8) !== 0) {\n            checkByte = (cdfh.modificationTime >> 8) & 0xff; // check MSB of the file time\n        } else {\n            checkByte = (cdfh.crc >> 24) & 0xff; // check MSB of CRC\n        }\n\n        if (decryptedHeader[11] !== checkByte) {\n            throw new Error(\"ZipCrypto: The password did not match.\");\n        }\n\n        const out = new Uint8Array(data.length - 12);\n        for (let i = 12; i < data.length; i += 1) {\n            const c = ZipCrypto.decryptByte(keys, data[i]);\n            out[i - 12] = c;\n        }\n        return out;\n    }\n}\n","// ZipFile.ts - ZIP file handling\n// (c) Marco Vieth, 2019\n//\n// Idea based on: https://github.com/frash23/jzsip/blob/master/jzsip.js (and Cpcemu: zip.cpp)\n// https://pkwaredownloads.blob.core.windows.net/pkware-general/Documentation/APPNOTE-6.3.9.TXT\n//\n\nimport { ZipCrypto } from \"./ZipCrypto\";\n\nexport interface ZipFileOptions {\n    data: Uint8Array\n}\n\ntype CodeType = {\n    count: number[],\n    symbol: number[]\n};\n\ninterface CentralDirFileHeader {\n    readonly signature: number\n    readonly version: number // version needed to extract (minimum)\n    readonly flag: number // General purpose bit flag\n        // bit 0: encrypted; bit 6: strong encryption; bit 13: central directory encrypted\n    readonly compressionMethod: number // compression method\n    readonly modificationTime: number // File last modification time (DOS time)\n    readonly crc: number // CRC-32 of uncompressed data\n    readonly compressedSize: number // compressed size\n    readonly size: number // Uncompressed size\n    readonly fileNameLength: number // file name length\n    readonly extraFieldLength: number // extra field length\n    readonly fileCommentLength: number // file comment length\n    readonly localOffset: number // relative offset of local file header\n    name: string\n    isDirectory: boolean\n    extra: Uint8Array\n    comment: string\n    timestamp: number\n    dataStart: number\n}\n\nexport type ZipDirectoryType = Record<string, CentralDirFileHeader>\n\ninterface EndOfCentralDir {\n    readonly signature: number\n    readonly entries: number // total number of central directory records\n    readonly cdfhOffset: number // offset of start of central directory, relative to start of archive\n    readonly cdSize: number // size of central directory (just for information)\n}\n\nconst ZipConstants = {\n    eocdSignature: 0x06054B50, // EOCD signature: \"PK\\x05\\x06\"\n    cdfhSignature: 0x02014B50, // Central directory file header signature: PK\\x01\\x02\"\n    lfhSignature: 0x04034B50, // Local file header signature: \"PK\\x03\\x04\"\n    eocdLen: 22, // End of central directory (EOCD)\n    cdfhLen: 46, // Central directory file header length\n    lfhLen: 30 // Local file header length\n};\n\nfunction textDecoderDecodePolyfill(data: Uint8Array): string {\n    const callSize = 25000; // use call window to avoid \"maximum call stack error\" for e.g. size 336461\n    let out = \"\";\n    let len = data.length;\n    let offset = 0;\n\n    while (len > 0) {\n        const chunkLen = Math.min(len, callSize);\n        const nums = data.subarray(offset, offset + chunkLen);\n\n        out += String.fromCharCode.apply(null, nums as unknown as number[]); // on Chrome this is faster than single character processing\n        offset += chunkLen;\n        len -= chunkLen;\n    }\n    return out;\n}\n\nexport class ZipFile {\n    private readonly options: ZipFileOptions;\n\n    private data!: Uint8Array;\n    private entryTable: ZipDirectoryType = {};\n    private static textDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { fatal: false }) : { decode: textDecoderDecodePolyfill };\n\n    constructor(options: ZipFileOptions) {\n        this.options = {} as ZipFileOptions;\n        this.setOptions(options, true);\n    }\n\n    // Get current options\n    // Note: The data option is returned as is (no copy)\n    public getOptions(): ZipFileOptions {\n        return this.options;\n    }\n\n    // Set options\n    // If force is true, the ZIP directory is re-read even if the data option has not changed\n    // Note: The data option is used as is (no copy)\n    public setOptions(options: Partial<ZipFileOptions>, force: boolean): void {\n        const currentData = this.options.data;\n\n        Object.assign(this.options, options);\n        if (force || (this.options.data !== currentData)) {\n            this.data = this.options.data;\n            this.entryTable = this.readZipDirectory();\n        }\n    }\n\n    // Get the ZIP directory (list of entries)\n    // Returns an object where the keys are the file names and the values are CentralDirFileHeader objects\n    // Note: Directories are also included in the list\n    public getZipDirectory(): ZipDirectoryType {\n        return this.entryTable;\n    }\n\n    // Convert Uint8Array to UTF-8 string\n    // Uses TextDecoder if available, otherwise a polyfill\n    // Note: The polyfill may be slow for large data\n    public static convertUint8ArrayToUtf8(data: Uint8Array): string {\n        return ZipFile.textDecoder.decode(data);\n    }\n\n    private static getUint16(data: Uint8Array, i: number): number {\n        return ((data[i + 1]) << 8) | data[i];\n    }\n\n    private static getUint32(data: Uint8Array, i: number): number {\n        return (data[i + 3] << 24) | (data[i + 2] << 16) | (data[i + 1] << 8) | data[i];\n    }\n\n    private readAsUTF8(offset: number, len: number): string {\n        const data = this.data.subarray(offset, offset + len);\n        return ZipFile.convertUint8ArrayToUtf8(data);\n    }\n\n    private readEocd(eocdPos: number): EndOfCentralDir { // read End of central directory\n        const data = this.data;\n        const eocd: EndOfCentralDir = {\n            signature: ZipFile.getUint32(data, eocdPos),\n            entries: ZipFile.getUint16(data, eocdPos + 10), // total number of central directory records\n            cdfhOffset: ZipFile.getUint32(data, eocdPos + 16), // offset of start of central directory, relative to start of archive\n            cdSize: ZipFile.getUint32(data, eocdPos + 20) // size of central directory (just for information)\n        };\n\n        return eocd;\n    }\n\n    private readCdfh(pos: number): CentralDirFileHeader { // read Central directory file header\n        const data = this.data;\n        const cdfh: CentralDirFileHeader = {\n            signature: ZipFile.getUint32(data, pos),\n            version: ZipFile.getUint16(data, pos + 6), // version needed to extract (minimum)\n            flag: ZipFile.getUint16(data, pos + 8), // General purpose bit flag\n            compressionMethod: ZipFile.getUint16(data, pos + 10), // compression method\n            modificationTime: ZipFile.getUint16(data, pos + 12), // File last modification time (DOS time)\n            crc: ZipFile.getUint32(data, pos + 16), // CRC-32 of uncompressed data\n            compressedSize: ZipFile.getUint32(data, pos + 20), // compressed size\n            size: ZipFile.getUint32(data, pos + 24), // Uncompressed size\n            fileNameLength: ZipFile.getUint16(data, pos + 28), // file name length\n            extraFieldLength: ZipFile.getUint16(data, pos + 30), // extra field length\n            fileCommentLength: ZipFile.getUint16(data, pos + 32), // file comment length\n            localOffset: ZipFile.getUint32(data, pos + 42), // relative offset of local file header\n\n            // set later...\n            name: \"\",\n            isDirectory: false,\n            extra: [] as unknown as Uint8Array,\n            comment: \"\",\n            timestamp: 0,\n            dataStart: 0\n        };\n\n        return cdfh;\n    }\n\n    private readZipDirectory(): ZipDirectoryType {\n        const maxEocdCommentLen = 0xffff,\n            data = this.data,\n            entryTable: ZipDirectoryType = {};\n\n        // find End of central directory (EOCD) record\n        let i = data.length - ZipConstants.eocdLen + 1, // +1 because of loop\n            eocd: EndOfCentralDir | undefined;\n\n        const n = Math.max(0, i - maxEocdCommentLen);\n\n        while (i >= n) {\n            i -= 1;\n            if (ZipFile.getUint32(data, i) === ZipConstants.eocdSignature) {\n                eocd = this.readEocd(i);\n                if (ZipFile.getUint32(data, eocd.cdfhOffset) === ZipConstants.cdfhSignature) {\n                    break; // looks good, so we assume that we have found the EOCD\n                }\n            }\n        }\n        if (!eocd) {\n            throw new Error(`Zip: File ended abruptly: EOCD not found at pos ${i >= 0 ? i : 0}`);\n        }\n\n        const entries = eocd.entries;\n        let offset = eocd.cdfhOffset;\n\n        for (i = 0; i < entries; i += 1) {\n            const cdfh = this.readCdfh(offset);\n\n            if (cdfh.signature !== ZipConstants.cdfhSignature) {\n                throw new Error(`Zip: Bad CDFH signatureat pos ${offset}`);\n            }\n            if (!cdfh.fileNameLength) {\n                throw new Error(`Zip Entry name missing at pos ${offset}`);\n            }\n            offset += ZipConstants.cdfhLen;\n\n            cdfh.name = this.readAsUTF8(offset, cdfh.fileNameLength);\n            offset += cdfh.fileNameLength;\n            cdfh.isDirectory = cdfh.name.charAt(cdfh.name.length - 1) === \"/\";\n\n            cdfh.extra = this.data.subarray(offset, offset + cdfh.extraFieldLength);\n            offset += cdfh.extraFieldLength;\n\n            cdfh.comment = this.readAsUTF8(offset, cdfh.fileCommentLength);\n            offset += cdfh.fileCommentLength;\n\n            if ((cdfh.flag & 0x40) === 0x40) { // bit 6 set?\n                throw new Error(`Zip: Strong encryption not suppoered.`);\n            }\n\n            if ((cdfh.flag & 0x2000) === 0x2000) { // bit 13 set?\n                throw new Error(`Zip: Strong directory encryption not suppoered.`);\n            }\n\n            const dostime = cdfh.modificationTime;\n\n            // year, month, day, hour, minute, second\n            cdfh.timestamp = new Date(((dostime >> 25) & 0x7F) + 1980, ((dostime >> 21) & 0x0F) - 1, (dostime >> 16) & 0x1F, (dostime >> 11) & 0x1F, (dostime >> 5) & 0x3F, (dostime & 0x1F) << 1).getTime();\n\n            // local file header... much more info\n            if (ZipFile.getUint32(data, cdfh.localOffset) !== ZipConstants.lfhSignature) {\n                console.error(\"Zip: readZipDirectory: LFH signature not found at offset\", cdfh.localOffset);\n            }\n\n            const lfhExtrafieldLength = ZipFile.getUint16(data, cdfh.localOffset + 28); // extra field length\n\n            cdfh.dataStart = cdfh.localOffset + ZipConstants.lfhLen + cdfh.name.length + lfhExtrafieldLength;\n\n            entryTable[cdfh.name] = cdfh;\n        }\n        return entryTable;\n    }\n\n    private static fnInflateConstruct(codes: CodeType, lens2: number[], n: number): number {\n        let i: number;\n\n        for (i = 0; i <= 0xF; i += 1) {\n            codes.count[i] = 0;\n        }\n\n        for (i = 0; i < n; i += 1) {\n            codes.count[lens2[i]] += 1;\n        }\n\n        if (codes.count[0] === n) {\n            return 0;\n        }\n\n        let left = 1;\n\n        for (i = 1; i <= 0xF; i += 1) {\n            if ((left = (left << 1) - codes.count[i]) < 0) {\n                return left;\n            }\n        }\n\n        const offs = [\n            undefined,\n            0\n        ];\n\n        for (i = 1; i < 0xF; i += 1) {\n            offs[i + 1] = offs[i]! + codes.count[i];\n        }\n\n        for (i = 0; i < n; i += 1) {\n            if (lens2[i] !== 0) {\n                codes.symbol[offs[lens2[i]] as number] = i; // TTT\n                (offs[lens2[i]] as number) += 1; // TTT\n            }\n        }\n        return left;\n    }\n\n    private static fnConstructFixedHuffman(lens: number[], lenCode: CodeType, distCode: CodeType): void { //TTT untested?\n        let symbol: number;\n\n        for (symbol = 0; symbol < 0x90; symbol += 1) {\n            lens[symbol] = 8;\n        }\n        for (; symbol < 0x100; symbol += 1) {\n            lens[symbol] = 9;\n        }\n        for (; symbol < 0x118; symbol += 1) {\n            lens[symbol] = 7;\n        }\n        for (; symbol < 0x120; symbol += 1) {\n            lens[symbol] = 8;\n        }\n        ZipFile.fnInflateConstruct(lenCode, lens, 0x120);\n        for (symbol = 0; symbol < 0x1E; symbol += 1) {\n            lens[symbol] = 5;\n        }\n        ZipFile.fnInflateConstruct(distCode, lens, 0x1E);\n    }\n\n    private inflate(data: Uint8Array, offset: number, compressedSize: number, finalSize: number): Uint8Array {\n        const startLens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258],\n            lExt = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],\n            dists = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],\n            dExt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n            dynamicTableOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n            bufEnd = offset + compressedSize,\n            outBuf = new Uint8Array(finalSize);\n        let inCnt = offset, // read position\n            outCnt = 0, // bytes written to outbuf\n            bitCnt = 0, // helper to keep track of where we are in #bits\n            bitBuf = 0,\n            distCode: CodeType,\n            lenCode: CodeType,\n            lens: number[];\n\n        const fnBits = function (need: number) {\n            let out = bitBuf;\n\n            while (bitCnt < need) {\n                if (inCnt === bufEnd) {\n                    throw new Error(`Zip: inflate: Data overflow`);\n                }\n                out |= data[inCnt] << bitCnt;\n                inCnt += 1;\n                bitCnt += 8;\n            }\n            bitBuf = out >> need;\n            bitCnt -= need;\n            return out & ((1 << need) - 1);\n        },\n\n            fnDecode = function (codes: CodeType) {\n                let code = 0,\n                    first = 0,\n                    i = 0;\n\n                for (let j = 1; j <= 0xF; j += 1) {\n                    code |= fnBits(1);\n                    const count = codes.count[j];\n\n                    if (code < first + count) {\n                        return codes.symbol[i + (code - first)];\n                    }\n                    i += count;\n                    first += count;\n                    first <<= 1;\n                    code <<= 1;\n                }\n                return null;\n            },\n\n            fnInflateStored = function () {\n                bitBuf = 0;\n                bitCnt = 0;\n                if (inCnt + 4 > bufEnd) {\n                    throw new Error(`Zip: inflate: Data overflow at pos ${inCnt}`);\n                }\n\n                let len = ZipFile.getUint16(data, inCnt);\n\n                inCnt += 2;\n\n                if (data[inCnt] !== (~len & 0xFF) || data[inCnt + 1] !== ((~len >> 8) & 0xFF)) {\n                    throw new Error(`Zip: inflate: Bad length at pos ${inCnt}`);\n                }\n                inCnt += 2;\n\n                if (inCnt + len > bufEnd) {\n                    throw new Error(`Zip: inflate: Data overflow at pos ${inCnt}`);\n                }\n\n                // Compatibility: Instead of: outbuf.push.apply(outbuf, outbuf.slice(incnt, incnt + len)); outcnt += len; incnt += len;\n                while (len) {\n                    outBuf[outCnt] = data[inCnt];\n                    outCnt += 1;\n                    inCnt += 1;\n                    len -= 1;\n                }\n            },\n\n            fnConstructDynamicHuffman = function () {\n                const nLen = fnBits(5) + 257,\n                    nDist = fnBits(5) + 1,\n                    nCode = fnBits(4) + 4;\n\n                if (nLen > 0x11E || nDist > 0x1E) {\n                    throw new Error(`Zip: inflate: length/distance code overflow`);\n                }\n                let i: number;\n\n                for (i = 0; i < nCode; i += 1) {\n                    lens[dynamicTableOrder[i]] = fnBits(3);\n                }\n                for (; i < 19; i += 1) {\n                    lens[dynamicTableOrder[i]] = 0;\n                }\n                if (ZipFile.fnInflateConstruct(lenCode, lens, 19) !== 0) {\n                    throw new Error(`Zip: inflate: length codes incomplete`);\n                }\n\n                for (i = 0; i < nLen + nDist;) {\n                    let symbol = fnDecode(lenCode) as number; // TTT\n\n                    if (symbol < 16) {\n                        lens[i] = symbol;\n                        i += 1;\n                    } else {\n                        let len = 0;\n\n                        if (symbol === 16) {\n                            if (i === 0) {\n                                throw new Error(`Zip: inflate: repeat lengths with no first length`);\n                            }\n                            len = lens[i - 1];\n                            symbol = 3 + fnBits(2);\n                        } else if (symbol === 17) {\n                            symbol = 3 + fnBits(3);\n                        } else {\n                            symbol = 11 + fnBits(7);\n                        }\n\n                        if (i + symbol > nLen + nDist) {\n                            throw new Error(`Zip: inflate: more lengths than specified`);\n                        }\n                        while (symbol) {\n                            lens[i] = len;\n                            symbol -= 1;\n                            i += 1;\n                        }\n                    }\n                }\n                const err1 = ZipFile.fnInflateConstruct(lenCode, lens, nLen),\n                    err2 = ZipFile.fnInflateConstruct(distCode, lens.slice(nLen), nDist);\n\n                if ((err1 < 0 || (err1 > 0 && nLen - lenCode.count[0] !== 1))\n                    || (err2 < 0 || (err2 > 0 && nDist - distCode.count[0] !== 1))) {\n                    throw new Error(`Zip: inflate: bad literal or length codes`);\n                }\n            },\n\n            fnInflateHuffmann = function () {\n                let symbol: number;\n\n                do { // decode deflated data\n                    symbol = fnDecode(lenCode) as number; // TTT\n                    if (symbol < 256) {\n                        outBuf[outCnt] = symbol;\n                        outCnt += 1;\n                    }\n                    if (symbol > 256) {\n                        symbol -= 257;\n                        if (symbol > 28) {\n                            throw new Error(`Zip: inflate: Invalid length/distance`);\n                        }\n                        let len = startLens[symbol] + fnBits(lExt[symbol]);\n\n                        symbol = fnDecode(distCode) as number; // TTT\n                        const dist = dists[symbol] + fnBits(dExt[symbol]);\n\n                        if (dist > outCnt) {\n                            throw new Error(`Zip: inflate: distance out of range`);\n                        }\n                        // instead of outbuf.slice, we use...\n                        while (len) {\n                            outBuf[outCnt] = outBuf[outCnt - dist];\n                            len -= 1;\n                            outCnt += 1;\n                        }\n                    }\n                } while (symbol !== 256);\n            };\n\n        let last: number;\n\n        do { // The actual inflation\n            last = fnBits(1);\n            const type = fnBits(2);\n\n            switch (type) {\n                case 0: // STORED\n                    fnInflateStored();\n                    break;\n                case 1:\n                case 2: // fixed (=1) or dynamic (=2) huffman\n                    lenCode = {\n                        count: [],\n                        symbol: []\n                    };\n                    distCode = {\n                        count: [],\n                        symbol: []\n                    };\n                    lens = [];\n                    if (type === 1) { // construct fixed huffman tables\n                        ZipFile.fnConstructFixedHuffman(lens, lenCode, distCode);\n                    } else { // construct dynamic huffman tables\n                        fnConstructDynamicHuffman();\n                    }\n\n                    fnInflateHuffmann();\n\n                    break;\n                default:\n                    throw new Error(`Zip: inflate: unsupported compression type ${type}`);\n            }\n        } while (!last);\n        return outBuf;\n    }\n\n    // Read binary data of a file entry (decompressing and decrypting if needed)\n    // password is required for encrypted files\n    // Throws error if file not found, password missing or incorrect, or compression method not supported\n    // Returns Uint8Array with file data\n    // Note: Directories cannot be read (will throw \"file not found\" error)\n    public readBinaryData(name: string, password?: string): Uint8Array {\n        const data = this.data;\n        const cdfh = this.entryTable[name];\n        if (!cdfh) {\n            throw new Error(`Zip: readBinaryData: File does not exist: ${name}`);\n        }\n\n        const isEncrypted = ZipCrypto.isEncrypted(cdfh);\n        console.log(`Zip: Extracting ${name}: compressedSize=${cdfh.compressedSize} size=${cdfh.size} compressionMethod=${cdfh.compressionMethod} encrypted=${isEncrypted}`);\n\n        let fileData = data.subarray(cdfh.dataStart, cdfh.dataStart + cdfh.compressedSize);\n        if (isEncrypted) {\n            if (!password) {\n                throw new Error(`Zip: Password required`);\n            }\n            fileData = ZipCrypto.decrypt(fileData, cdfh, password); // read encrypted data (includes 12-byte header)\n        }\n\n        if (cdfh.compressionMethod === 0) { // stored\n        } else if (cdfh.compressionMethod === 8) { // deflated\n            fileData = this.inflate(fileData, 0, cdfh.compressedSize, cdfh.size);\n        } else {\n            throw new Error(`Zip: readBinaryData: compression method not supported ${cdfh.compressionMethod}`);\n        }\n        return fileData;\n    }\n\n    // Check if the data looks like a ZIP file\n    // (checks only for Local File Header signature at the beginning of the file)\n    public static isProbablyZipFile(data: Uint8Array): boolean {\n        if (data.length < 4) {\n            return false; // too short to be a valid ZIP file\n        }\n        // check for the Local File Header (LFH) signature at the beginning of the file (we ignore that there can be any preceding data)\n        const lfhSignature = ZipConstants.lfhSignature;\n        const i = 0; // we only check the first 4 bytes\n        const firstFourBytes = (data[i + 3] << 24) | (data[i + 2] << 16) | (data[i + 1] << 8) | data[i];\n        if (firstFourBytes !== lfhSignature) {\n            return false; // does not start with the Local File Header signature\n        }\n        return true; // it looks like a ZIP file\n    }\n}\n","import './style.css';\nimport L from 'leaflet';\nimport 'leaflet.markercluster';\nimport type { FeatureGroup, MarkerClusterGroup } from 'leaflet';\n\nimport LatLng from \"./LatLng\";\nimport ScriptParser, { type ValueType, type VariableAccessType } from './ScriptParser';\nimport { ZipFile } from \"./ZipFile\";\n\ndeclare global {\n    interface Window {\n        GPXmap: {\n            addItem: (key: string, input: string) => void\n        };\n    }\n}\n\nexport type ConfigEntryType = string | number | boolean;\n\ntype ConfigType = {\n    debug: number;\n    file: string,\n    search: string;\n};\n\nconst config: ConfigType = {\n    debug: 0,\n    file: \"\",\n    search: \"\"\n};\n\n\ntype WaypointDataType = {\n    name: string;\n    lat: number;\n    lon: number;\n    type: string;\n    desc: string;\n    cacheInfo: string;\n    solverCode: string;\n    solverCodeEdited?: string;\n};\n\ntype WaypointDataMapType = Record<string, WaypointDataType>;\n\ntype MarkerType = L.Marker & {\n    waypointName: string;\n};\n\nconst waypointDataMap: WaypointDataMapType = {}; // Store markers data for filtering\n\nconst map = L.map('map');\nconst waypointGroup = L.markerClusterGroup();\nconst popup = L.popup();\n\nconst solverGroup = L.featureGroup();\nconst solverPopup = L.popup();\n\n// Marker pool for reuse\nconst markerPool: MarkerType[] = [];\n\nfunction asyncDelay(fn: () => void, timeout: number) {\n    (() => {\n        const timerId = window.setTimeout(fn, timeout);\n        return timerId;\n    })();\n}\n\nfunction deleteAllItems(items: Record<string, unknown>) {\n    Object.keys(items).forEach(key => delete items[key]);\n}\n\nfunction debounce(fn: (e: Event) => void, delay: number) {\n    let timeoutId: number | undefined;\n    return (e: Event) => {\n        clearTimeout(timeoutId);\n        timeoutId = window.setTimeout(() => fn(e), delay);\n    };\n}\n\nfunction setButtonDisabled(id: string, disabled: boolean) {\n    const element = window.document.getElementById(id) as HTMLButtonElement;\n    element.disabled = disabled;\n}\n\n// Get a marker from the pool or create a new one\nfunction getPooledMarker(lat: number, lon: number, icon: L.DivIcon, name: string): MarkerType {\n    let marker: MarkerType;\n    if (markerPool.length > 0) {\n        marker = markerPool.pop()!;\n        marker.setLatLng([lat, lon]);\n        marker.setIcon(icon);\n    } else {\n        marker = L.marker([lat, lon], { icon }) as MarkerType;\n    }\n    marker.waypointName = name;\n    return marker;\n}\n\n// When clearing markers, return them to the pool\nfunction clearMarkersFromGroup(group: MarkerClusterGroup | FeatureGroup): void {\n    group.eachLayer(layer => {\n        if (layer instanceof L.Marker) {\n            markerPool.push(layer as MarkerType);\n        }\n    });\n    group.clearLayers();\n}\n\n// Define custom icons for cache types\nconst iconColors: Record<string, string> = {\n    'Geocache|Earthcache': 'brown',\n    'Geocache|Event Cache': 'fireBrick',\n    'Geocache|Letterbox Hybrid': 'yellow',\n    'Geocache|Multi-cache': 'orange',\n    'Geocache|Traditional Cache': 'green',\n    'Geocache|Unknown Cache': 'CornFlowerBlue', // Mystery Cache\n    'Geocache|Webcam Cache': 'DarkTurquoise',\n    'Waypoint|Parking Area': 'gray',\n    'Waypoint|Physical Stage': 'gray',\n    'Waypoint|Reference Point': 'gray',\n    'Waypoint|Trailhead': 'gray',\n    'Waypoint|Virtual Stage': 'lightblue',\n    Location: 'transparent',\n    Solver: 'transparent',\n    Default: 'gray'\n};\n\nconst iconCache: Record<string, L.DivIcon> = {};\n\nfunction getIcon(cacheType: string): L.DivIcon {\n    const color = iconColors[cacheType] || iconColors.Default;\n    if (!iconCache[color]) {\n        const size = cacheType === 'Location' ? 22 : 18; // size of the icon\n        iconCache[cacheType] = L.divIcon({\n            className: 'custom-cache-icon',\n            // circle with x in the middle\n            html: `<svg width=\"${size}\" height=\"${size}\" stroke=\"black\" stroke-width=\"1\">\n            <circle cx=\"${size / 2}\" cy=\"${size / 2}\" r=\"${size / 2 - 1}\" fill=\"${color}\" />\n            <line x1=\"${size * 0.27}\" y1=\"${size * 0.27}\" x2=\"${size * 0.73}\" y2=\"${size * 0.73}\" />\n            <line x1=\"${size * 0.73}\" y1=\"${size * 0.27}\" x2=\"${size * 0.27}\" y2=\"${size * 0.73}\" />\n            </svg>`,\n            iconSize: [size, size],\n            iconAnchor: [size / 2, size / 2],\n            popupAnchor: [0, -size / 2]\n        });\n    }\n    return iconCache[cacheType];\n}\n\n// Helper to render (filtered) markers\nfunction renderMarkers(markersData: WaypointDataType[], keepView: boolean): void {\n    if (map.hasLayer(waypointGroup)) {\n        clearMarkersFromGroup(waypointGroup);\n        map.removeLayer(waypointGroup);\n    }\n\n    if (markersData.length > 0) {\n        markersData.forEach(data => {\n            const marker = getPooledMarker(data.lat, data.lon, getIcon(data.type), data.name);\n            waypointGroup.addLayer(marker);\n        });\n        waypointGroup.addTo(map);\n        if (!keepView) {\n            map.fitBounds(waypointGroup.getBounds().pad(0.5));\n        }\n    }\n}\n\nconst polylineGroup = L.featureGroup(); // featureGroup for polyline\n\nfunction privSetPolyline(path: L.LatLng[]) {\n    const aLayers = polylineGroup.getLayers();\n\n    if (aLayers.length) {\n        const oPolyline = aLayers[0] as L.Polyline;\n        oPolyline.setLatLngs(path);\n    } else {\n        const mPolylineOptions = {\n            color: \"blue\", // \"red\", // default: #3388FF\n            weight: 2, // default: 3\n            opacity: 0.7 // default: 1\n        };\n        const oPolyline = new L.Polyline(path, mPolylineOptions);\n        oPolyline.addTo(polylineGroup);\n    }\n}\n\nfunction setPolyline(solverMarkersData: WaypointDataType[]) { // for update\n    polylineGroup.clearLayers();\n    const aPath = [];\n    for (let i = 0; i < solverMarkersData.length; i += 1) {\n        const oItem = solverMarkersData[i];\n        const oPosition = new L.LatLng(oItem.lat, oItem.lon); //oItem.position.clone();\n        aPath.push(oPosition);\n    }\n\n    privSetPolyline(aPath);\n}\n\nconst solverDataMap: WaypointDataMapType = {};\n\nfunction renderSolverMarkers(solverMarkersData: WaypointDataType[]): void {\n    if (map.hasLayer(solverGroup)) {\n        clearMarkersFromGroup(solverGroup);\n        map.removeLayer(solverGroup);\n    }\n    deleteAllItems(solverDataMap);\n\n    if (solverMarkersData.length > 0) {\n        solverMarkersData.forEach(data => {\n            const marker = getPooledMarker(data.lat, data.lon, getIcon(data.type), data.name);\n            solverGroup.addLayer(marker);\n            solverDataMap[data.name] = data;\n        });\n        solverGroup.addTo(map);\n    }\n}\n\n// Filter logic\nfunction filterWaypoints(query: string): void {\n    const q = query.trim().toLowerCase();\n    const keepView = document.getElementById('keepViewInput') as HTMLInputElement;\n    const waypointData = Object.values(waypointDataMap);\n    const waypointCount = document.getElementById('waypointCount') as HTMLSpanElement;\n    if (!q) {\n        renderMarkers(waypointData, keepView.checked);\n        waypointCount.innerText = String(waypointData.length);\n        return;\n    }\n    const filtered = waypointData.filter(data => {\n        return (\n            data.name.toLowerCase().includes(q) ||\n            data.desc.toLowerCase().includes(q) ||\n            data.cacheInfo.toLowerCase().includes(q)\n        );\n    });\n    renderMarkers(filtered, keepView.checked);\n    waypointCount.innerText = `${filtered.length} / ${waypointData.length}`;\n}\n\nfunction insertNewlineAtLastMatch(str: string, find: string, keepMatch: boolean): string {\n    const lastMatch = str.lastIndexOf(find);\n    if (lastMatch < 0) {\n        return str;\n    }\n    const matchLen = find.length;\n    const add = keepMatch ? 1 : matchLen;\n    const result = [str.substring(0, lastMatch).trim(), str.substring(lastMatch + add).trim()].join('<br>\\n');\n    return result;\n}\n\nfunction position2dmm(lat: number, lon: number): string {\n    const latAbs = Math.abs(lat);\n    const lonAbs = Math.abs(lon);\n    const latNS = lat >= 0 ? \"N\" : \"S\";\n    const lonEW = lon >= 0 ? \"E\" : \"W\";\n    const latDeg = Math.floor(latAbs);\n    const latMin = (latAbs - latDeg) * 60;\n    const lonDeg = Math.floor(lonAbs);\n    const lonMin = (lonAbs - lonDeg) * 60;\n    return latNS + \" \" + String(latDeg).padStart(2, '0') + \" \" + latMin.toFixed(3).padStart(6, '0') + \" \" + lonEW + \" \" + String(lonDeg).padStart(3, '0') + \" \" + lonMin.toFixed(3).padStart(6, '0');\n}\n\nconst directions = [\"N\", \"NNE\", \"NE\", \"ENE\", \"E\", \"ESE\", \"SE\", \"SSE\", \"S\", \"SSW\", \"SW\", \"WSW\", \"W\", \"WNW\", \"NW\", \"NNW\"];\n\nfunction getDirection(bearing: number): string {\n    return directions[Math.round(bearing / (360 / directions.length)) % directions.length];\n}\n\nfunction formatDistance(distance: number) {\n    if (distance > 1000) {\n        return (distance / 1000).toFixed(3) + ' km';\n    }\n    return distance.toFixed(2) + ' m';\n}\n\nfunction getBearing(from: L.LatLng, to: L.LatLng): number {\n    const toRad = (deg: number) => deg * Math.PI / 180;\n    const toDeg = (rad: number) => rad * 180 / Math.PI;\n\n    const lat1 = toRad(from.lat);\n    const lat2 = toRad(to.lat);\n    const dLon = toRad(to.lng - from.lng);\n\n    const y = Math.sin(dLon) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n    const brng = Math.atan2(y, x);\n    return (toDeg(brng) + 360) % 360; // Normalize to 0-360\n}\n\nfunction preparePopupContent(data: WaypointDataType, solverCodeInHtml: string, distance: number, bearing: number): string {\n    let moreInfo = '';\n \n    if (data.cacheInfo) {\n       moreInfo =  `\n    <details style=\"margin-top:4px;\">\n        <summary>More info</summary>\n        <div style=\"margin-top:4px;\">\n            <div style=\"margin:0;max-height:120px;overflow:auto;border:1px solid #ccc;padding:4px;background:#fafafa;\">\n                ${data.cacheInfo}${solverCodeInHtml}\n            </div>\n        </div>\n    </details>`;\n    } else if (data.type === 'Solver' && selectedMarker) {\n        // With markerCluster, the marker position may be different than the position in the data!\n        const searchPoint = L.latLng(data.lat, data.lon);\n        const threshold = 1; // threshold in meters\n        const mainData = waypointDataMap[selectedMarker.waypointName];\n        const mainLatLng = mainData ? L.latLng(mainData.lat, mainData.lon) : null;\n        if (mainLatLng && (searchPoint.distanceTo(mainLatLng) <= threshold)) {\n            const wpPopupContent = popup.getContent() as string;\n            moreInfo =  `\n    <details style=\"margin-top:4px;\">\n        <summary>Marker ${selectedMarker.waypointName}</summary>\n        <div style=\"margin-top:4px;\">\n            <div style=\"margin:0;max-height:120px;overflow:auto;border:1px solid #ccc;padding:4px;background:#fafafa;\">\n                ${wpPopupContent}\n            </div>\n        </div>\n    </details>`;\n        }\n\n    }\n\n    const dmm = position2dmm(data.lat, data.lon);\n    const desc = insertNewlineAtLastMatch(insertNewlineAtLastMatch(data.desc, ' by ', true), ',', false);\n    const distanceStr = distance >= 0 ? `<br>Distance: ${formatDistance(distance)} ${getDirection(bearing)} (${bearing.toFixed(0)})` : '';\n    const name = data.name;\n    const nameStr = name.startsWith(\"GC\") ? `<a href=\"https://coord.info/${name}\" target=\"_blank\">${name}</a>` : name;\n    \n    return `\n<strong>${nameStr}</strong><br>\n<span>${desc}</span><br>\n<small>${dmm}${distanceStr}</small>\n${moreInfo}\n`;\n}\n\nfunction getWaypointFromLocalStorage(key: string): WaypointDataType | undefined {\n    const storedData = window.localStorage.getItem(key);\n    if (storedData) {\n        const data = JSON.parse(storedData) as Partial<WaypointDataType>;\n        const wp: WaypointDataType = {\n            name: data.name || '',\n            lat: Number(data.lat) || 0,\n            lon: Number(data.lon) || 0,\n            type: data.type || '',\n            desc: data.desc || '',\n            cacheInfo: data.cacheInfo || '',\n            solverCode: data.solverCode || '',\n            solverCodeEdited: data.solverCodeEdited,\n        };\n        return wp;\n    }\n    return undefined;\n}\n\nfunction getSolverCode(key: string) {\n    const data = waypointDataMap[key];\n    return data ? data.solverCodeEdited || data.solverCode : '';\n}\n\nfunction putWaypointAndSolverIntoLocalStorage(key: string, waypoint: WaypointDataType) {\n    window.localStorage.setItem(key, JSON.stringify(waypoint));\n}\n\nfunction removeKeyFromLocalStorage(key: string) {\n    window.localStorage.removeItem(key);\n}\n\nfunction loadWaypointsFromLocalStorage() {\n    for (let i = 0; i < window.localStorage.length; i++) {\n        const key = window.localStorage.key(i);\n        if (key && key.startsWith('GC')) { // Only load geocache waypoints\n            const waypoint = getWaypointFromLocalStorage(key);\n            if (waypoint) {\n                waypointDataMap[key] = waypoint; // always override\n            }\n        }\n    }\n}\n\nfunction getSolverCodeInHtml(solverCode: string) {\n    if (solverCode) {\n        const solverCodePrepared = solverCode.replace(/\\n/g, '<br>\\n');\n        return `<details><summary>Solver</summary><div class=\"gc_solver\">${solverCodePrepared}<br>\\n</div></details>\\n`;\n    }\n    return '';\n}\n\nfunction prepareInfoContent(data: WaypointDataType, solverCodeInHtml: string, distance: number, bearing: number): string {\n    const cacheInfo = `<br>\\n${data.cacheInfo || ''}${solverCodeInHtml}<br>\\n`;\n\n    const dmm = position2dmm(data.lat, data.lon);\n    const distanceStr = distance >= 0 ? `Distance: ${formatDistance(distance)} ${getDirection(bearing)} (${bearing.toFixed(0)})<br>\\n` : ''\n    const name = data.name;\n    const nanmeStr = name.startsWith(\"GC\") ? `<a href=\"https://coord.info/${name}\" target=\"_blank\">${name}</a>` : name;\n    const infoContent = `${nanmeStr}<br>\\n${dmm}<br>\\n${distanceStr}${data.desc}<br>\\n${cacheInfo}`;\n    return infoContent;\n}\n\nfunction getWaypointInfoHtml(): string {\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    return waypointInfo.innerHTML;\n}\n\nfunction setWaypointInfoHtml(html: string): void {\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    waypointInfo.innerHTML = html;\n}\n\nfunction parseSolverCode(input: string, variables: Record<string, ValueType>) {\n    if (input.includes('\\u2013')) {\n        console.warn(\"strange '-' found: '\\u2013'.\");\n    }\n\n    const variableAccess: VariableAccessType = {\n        vars: {},\n        get: (name: string) => {\n            let value = variables[name];\n            if (value === undefined) {\n                if (name.startsWith(\"$\")) {\n                    const name2 = name.substring(1);\n                    const waypointData = waypointDataMap[name2];\n                    if (waypointData) {\n                        value = position2dmm(waypointData.lat, waypointData.lon);\n                    }\n                }\n            }\n            return value;\n        },\n        set: (name: string, value: ValueType) => {\n            variables[name] = value;\n        } \n    }\n\n    try {\n        const output = new ScriptParser().calculate(input, variableAccess);\n        if (config.debug > 1) {\n            console.debug(\"DEBUG: parseSolverCode: \", output, variables);\n        }\n        return String(output);\n    } catch (e) {\n        const errorMsg = String(e);\n        console.error(errorMsg);\n        return `<span style=\"color: red\">Error: ${errorMsg}</span><br>\\n`;\n    }\n}\n\nfunction prepareSolverMarkersData(solverPoints: [string, string | number][]) {\n    const markersData = solverPoints.map((entry) => {\n        const [key, value] = entry;\n        const latLon = new LatLng().parse(String(value));\n        return {\n            name: key,\n            lat: latLon.getLat(),\n            lon: latLon.getLng(),\n            type: \"Solver\",\n            desc: latLon.getComment(),\n            cacheInfo: '',\n            solverCode: ''\n        }\n    });\n    return markersData;\n}\n\nlet selectedMarker: MarkerType | undefined = undefined;\n\nfunction selectMarker(marker: MarkerType): void {\n    selectedMarker = marker;\n    const data = waypointDataMap[marker.waypointName];\n\n    setButtonDisabled('editButton', false);\n    setButtonDisabled('saveButton', true); // TODO: do we need to save something?\n    setButtonDisabled('cancelButton', true);\n\n    const currentLatLng = locationMarker.getLatLng();\n    const isInitialLocation = currentLatLng.lat === 0 && currentLatLng.lng === 0;\n\n    // With markerCluster, the marker position may be different than the position in the data!\n    const dataLatLng = L.latLng(data.lat, data.lon);\n\n    const distance = isInitialLocation ? -1 : dataLatLng.distanceTo(currentLatLng);\n    const bearing = getBearing(currentLatLng, dataLatLng);\n\n    const solverCode = getSolverCode(data.name); // or: marker.waypointName\n    const solverCodeInHtml = getSolverCodeInHtml(solverCode);\n    let infoContent = prepareInfoContent(data, solverCodeInHtml, distance, bearing);\n\n    const popupContent = preparePopupContent(data, solverCodeInHtml, distance, bearing);\n\n    popup\n        .setLatLng(marker.getLatLng()) // use actual marker position for the popup position\n        .setContent(popupContent);\n\n    if (solverCode) {\n        const variables: Record<string, string | number> = {};\n        const text = parseSolverCode(solverCode, variables);\n        infoContent += `<br>Solver Result:<br>`;\n        if (text) {\n            infoContent += text.replace(/\\n/g, '<br>\\n');;\n        }\n        const solverPoints = Object.entries(variables).filter(([key]) => key.startsWith(\"$\"));\n        const solverMarkersData = prepareSolverMarkersData(solverPoints);\n        renderSolverMarkers(solverMarkersData);\n        setPolyline(solverMarkersData);\n    }\n\n    setWaypointInfoHtml(infoContent);\n}\n\nfunction selectSolverMarker(marker: MarkerType): void {\n    // no not set selectedMarker, keep it\n    const data = solverDataMap[marker.waypointName];\n    if (!data) {\n        console.error(\"selectSolverMarker: data not found for marker \", marker.waypointName);\n        solverPopup\n            .setLatLng(marker.getLatLng()) // use actual marker position for the popup position\n            .setContent(`<strong>${marker.waypointName}</strong><br><span style=\"color: red\">Data not found!</span>`);\n        return;\n    }\n\n    const currentLatLng = locationMarker.getLatLng();\n    const isInitialLocation = currentLatLng.lat === 0 && currentLatLng.lng === 0;\n    \n    // With markerCluster, the marker position may be different than the position in the data!\n    const dataLatLng = L.latLng(data.lat, data.lon);\n    const distance = isInitialLocation ? -1 : dataLatLng.distanceTo(currentLatLng);\n    const bearing = getBearing(currentLatLng, dataLatLng);\n  \n    const popupContent = preparePopupContent(data, '', distance, bearing);\n\n    solverPopup\n        .setLatLng(marker.getLatLng()) // use actual marker position for the popup position\n        .setContent(popupContent);\n}\n\nfunction clearSolverLayers(): void {\n    if (map.hasLayer(solverGroup)) {\n        clearMarkersFromGroup(solverGroup);\n        map.removeLayer(solverGroup);\n        polylineGroup.clearLayers();\n    }\n}\n\nfunction onWaypointGroupClick(e: L.LeafletMouseEvent): void {\n    clearSolverLayers();\n    const marker = e.propagatedFrom as MarkerType;\n    selectMarker(marker);\n}\n\nfunction onSolverGroupClick(e: L.LeafletMouseEvent): void {\n    const marker = e.propagatedFrom as MarkerType;\n    selectSolverMarker(marker);\n}\n\nfunction processZipFile(uint8Array: Uint8Array, zipName: string): string[] {\n    const messages: string[] = []\n    const zip = new ZipFile({\n        data: uint8Array\n    });\n\n    let password = '';\n\n    const zipDirectory = zip.getZipDirectory();\n    const entries = Object.keys(zipDirectory);\n\n    console.log(`processZipFile: ${zipName}: with ${entries.length} entries`);\n\n    for (let i = 0; i < entries.length; i += 1) {\n        const name = entries[i];\n\n        if (zipDirectory[name].isDirectory) {\n            console.log(`processZipFile: Ignoring directory: ${name}`);\n        } else if (name.startsWith(\"__MACOSX/\")) { // MacOS X creates some extra folder in ZIP files\n            console.log(`processZipFile: Ignoring file: ${name}`);\n        } else {\n            if ((zipDirectory[name].flag & 0x01) && !password) { // encrypted and no password set, yet?\n                password = prompt(`Password for ${name.split(\"/\").pop()}:`) || '';\n            }\n            try {\n                const binaryData = zip.readBinaryData(name, password);\n                if (binaryData) {\n                    if (name.endsWith('.zip') || ZipFile.isProbablyZipFile(binaryData)) {\n                        console.log(`File ${name} is a ZIP file, processing recursively.`);\n                        const messages2 = processZipFile(binaryData, name);\n                        messages.push(...messages2);\n                    } else {\n                        const utf8Text = ZipFile.convertUint8ArrayToUtf8(binaryData);\n                        const message = parseGpxFile(utf8Text, name);\n                        messages.push(message);\n                    }\n                }\n            } catch (e) {\n                const errorMsg = e instanceof Error ? e.message : String(e);\n                console.error(`File ${name}:`, errorMsg);\n                messages.push(`<span style=\"color: red\">File ${name}: ${errorMsg}</span><br>\\n`);\n            }\n        }\n    }\n    return messages;\n}\n\nfunction parseGpxFile(text: string, name: string): string {\n    const parser = new DOMParser();\n    if (text.includes(\"\\v\")) { // some special character?\n        text = text.replaceAll(\"\\v\", \" \");\n        console.warn(`File ${name}: Special VT character(s) removed.`);\n    }\n    const xml = parser.parseFromString(text, 'application/xml');\n\n    const errorNode = xml.querySelector(\"parsererror\");\n    if (errorNode) {\n        throw new Error(`Error parsing ${name}: ${errorNode.textContent}`);\n    }\n\n    let overwritten = 0;\n    const wpts = Array.from(xml.getElementsByTagName('wpt'));\n\n    for (const wpt of wpts) {\n        const lat = parseFloat(wpt.getAttribute('lat') || '0');\n        const lon = parseFloat(wpt.getAttribute('lon') || '0');\n        const name = wpt.getElementsByTagName('name')[0]?.textContent || 'Waypoint';\n        const desc = wpt.getElementsByTagName('desc')[0]?.textContent || '';\n        const type = wpt.getElementsByTagName('type')[0]?.textContent || '';\n\n        const cacheElem = wpt.getElementsByTagName('groundspeak:cache')[0];\n        let cacheInfo = '';\n        let solverCode = '';\n        if (cacheElem) {\n            const archived = (cacheElem.getAttribute('archived') || '').toLowerCase() === 'true';\n            const available = (cacheElem.getAttribute('available') || '').toLowerCase() === 'true';\n            const cacheName = cacheElem.getElementsByTagName('groundspeak:name')[0]?.textContent || '';\n            const cacheType = cacheElem.getElementsByTagName('groundspeak:type')[0]?.textContent || '';\n            const container = cacheElem.getElementsByTagName('groundspeak:container')[0]?.textContent || '';\n            const longDesc = cacheElem.getElementsByTagName('groundspeak:long_description')[0]?.textContent || '';\n            const hints = cacheElem.getElementsByTagName('groundspeak:encoded_hints')[0]?.textContent || '';\n            // TODO: logs?\n            cacheInfo = `- Cache Name: ${cacheName}<br>\\n- Type: ${cacheType}<br>\\n- Container: ${container}<br>\\n- Archived: ${archived}<br>\\n- Available: ${available}<br>\\n- Hints: ${hints}<br>\\n- Description:<br>\\n${longDesc}`;\n\n            // Extract solverCode from cacheInfo if present\n            const match = cacheInfo.match(/<details><summary>Solver<\\/summary><div class=\"gc_solver\">(.+?)<\\/div><\\/details>/s);\n            if (match && match[1]) {\n                solverCode = match[1].replace(/<br\\/?>(\\n)?/g, '\\n').trim();\n                const index = match.index || -1;\n                if (index >= 0) {\n                    cacheInfo = cacheInfo.substring(0, index); // strip solverCode\n                }\n            }\n        }\n        if (name in waypointDataMap) {\n            overwritten += 1;\n        }\n        waypointDataMap[name] = { name, lat, lon, type, desc, cacheInfo, solverCode };\n    }\n    const overwrittenStr = overwritten ? ` (overwritten: ${overwritten})` : '';\n    return `Processed file ${name} with ${wpts.length} waypoints${overwrittenStr}.`;\n}\n\n// Handle file upload (or file drop on map)\nasync function onFileInputChange(event: Event): Promise<void> {\n    let infoHtml = '';\n    setWaypointInfoHtml(infoHtml);\n\n    setButtonDisabled('editButton', true);\n    // TODO: save if something was changed?\n    setButtonDisabled('saveButton', true);\n\n    if (popup.isOpen()) {\n        popup.close();\n    }\n    if (solverPopup.isOpen()) {\n        solverPopup.close();\n    }\n    const startTime = Date.now();\n\n    // dataTransfer for drag&drop (with event.type=\"drop\"), target.files for file input \n    const dataTransfer = (event as DragEvent).dataTransfer;\n\tconst files = dataTransfer ? dataTransfer.files : (event.target as HTMLInputElement).files;\n    const inputElement = !dataTransfer ? (event.target as HTMLInputElement) : null;\n\n    if (!files || files.length === 0) {\n        return;\n    }\n\n    deleteAllItems(waypointDataMap); // Reset waypoint data map\n    deleteAllItems(solverDataMap); // Reset solver data map\n    clearSolverLayers();\n    filterWaypoints(\"\");\n\n    if (inputElement) {\n        inputElement.style.color = '';\n    }\n\n    for (const file of files) {\n        try {\n            if (file.type === 'application/x-zip-compressed' || file.type === 'application/zip') {\n                // on Mac OS it is \"application/zip\"\n                const arrayBuffer = await file.arrayBuffer();\n                const messages = processZipFile(new Uint8Array(arrayBuffer), file.name);\n                infoHtml += messages.map((message) => `<span>${message}</span><br>\\n`).join('');\n            } else {\n                let fileName = file.name;\n                let text = await file.text();\n                if (file.type === 'text/javascript' || file.type === 'application/x-javascript') { // FireFox and Safari use 'application/x-javascript'\n                    // We expect somewhere in the .js file: GPXmap.addItem(\"<filename>\", `<content>`), maybe spanning multiple lines. Filename can also have extension, e.g. file.zip.b64\n                    const result = /GPXmap\\.addItem\\(\"([^\"]+)\", `\\s*([^`]*)`\\)/.exec(text);\n                    if (result) {\n                        fileName = result[1];\n                        text = result[2];\n                        addItem(fileName, text);\n                    } else {\n                        throw new Error(\"onFileInputChange: GPXmap.addItem not found in JS file \" + fileName);\n                    }\n                } else {\n                    if (fileName.endsWith('.b64')) { // assuming Basic64 encoding\n                        text = atob(text);\n                        fileName = fileName.slice(0, -4); // Remove .b64 suffix\n                    }\n                    if (fileName.endsWith('.zip')) {\n                        const binaryData = new Uint8Array(text.split('').map(c => c.charCodeAt(0)));\n                        const messages = processZipFile(binaryData, file.name);\n                        infoHtml += messages.map((message) => `<span>${message}</span><br>\\n`).join('');\n                    } else { //if (fileName.endsWith('.gpx')) {\n                        // Process GPX file\n                        const message = parseGpxFile(text, file.name);\n                        infoHtml += `<span>${message}</span><br>\\n`;\n                    }\n                }\n            }\n        } catch (e) {\n            const errorMsg = e instanceof Error ? e.message : String(e);\n            console.error(errorMsg);\n            infoHtml += `<span style=\"color: red\">${errorMsg}</span><br>\\n`;\n            if (inputElement) {\n                inputElement.style.color = 'red';\n            }\n        }\n    }\n    setWaypointInfoHtml(getWaypointInfoHtml() + infoHtml); // add info (in debuggung mode there could be already some output)\n\n    const waypointSearch = document.getElementById('waypointSearch') as HTMLInputElement;\n    filterWaypoints(waypointSearch.value);\n\n    const endTime = Date.now();\n    console.log(`Processed in ${endTime - startTime} ms`);\n}\n\n\nfunction onEditButtonClick() {\n    if (!selectedMarker) {\n        console.error(\"No marker selected.\");\n        return;\n    }\n    const key = selectedMarker.waypointName;\n    const code = getSolverCode(key);\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    waypointInfo.innerText = code || '';\n    waypointInfo.setAttribute('contenteditable', \"true\");\n    setButtonDisabled('editButton', true);\n    setButtonDisabled('saveButton', false);\n    setButtonDisabled('cancelButton', false);\n    // no cancel?\n}\n\nfunction onSaveButtonClick() {\n    if (!selectedMarker) {\n        console.error(\"No marker selected.\");\n        return;\n    }\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    waypointInfo.setAttribute('contenteditable', \"false\");\n\n    const solverCodeEdited = waypointInfo.innerText.trim(); // to be sure, we want text only\n    const key = selectedMarker.waypointName;\n    const data = waypointDataMap[key];\n    if (data) {\n        if (solverCodeEdited) {\n            data.solverCodeEdited = solverCodeEdited; // update in memory\n            putWaypointAndSolverIntoLocalStorage(key, data);\n        } else {\n            delete data.solverCodeEdited; // remove from memory\n            removeKeyFromLocalStorage(key);\n        }\n    }\n    selectMarker(selectedMarker);\n    setButtonDisabled('editButton', false);\n    setButtonDisabled('cancelButton', true);\n}\n\nfunction onCancelButtonClick() {\n    if (!selectedMarker) {\n        console.error(\"No marker selected.\");\n        return;\n    }\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    waypointInfo.setAttribute('contenteditable', \"false\");\n    selectMarker(selectedMarker);\n    setButtonDisabled('editButton', false);\n    setButtonDisabled('cancelButton', true);\n}\n\nfunction onMapDragover(ev: DragEvent) {\n    ev.stopPropagation();\n    ev.preventDefault();\n    if (ev.dataTransfer !== null) {\n        ev.dataTransfer.dropEffect = \"copy\"; // explicitly show this is a copy\n    }\n}\n\nfunction getMarkerFromPopup(popup: L.Popup) {\n    return (popup as L.Popup & { _source: MarkerType })._source; // fast hack\n}\n\n// *** start location service\n\nfunction locationShowPosition(position: GeolocationPosition) {\n    const latitude = position.coords.latitude;\n    const longitude = position.coords.longitude;\n    const oldLocation = locationMarker.getLatLng();\n    const isInitialLocation = oldLocation.lat === 0 && oldLocation.lng === 0;\n    const dmm = position2dmm(latitude, longitude);\n    locationMarker.setLatLng([latitude, longitude]);\n    locationMarker.getPopup()?.setContent(`You are here!<br>${dmm}`);\n\n    if (isInitialLocation) {\n        const keepView = document.getElementById('keepViewInput') as HTMLInputElement;\n        if (!keepView.checked) {\n            const zoom = map.getZoom() > 12 ? map.getZoom() : 12;\n            map.setView([latitude, longitude], zoom);\n        }\n        locationMarker.addTo(map);\n    }\n\n    if (popup.isOpen()) {\n        const marker = getMarkerFromPopup(popup);\n        const data = waypointDataMap[marker.waypointName];\n        const currentLatLng = locationMarker.getLatLng();\n\n        // With markerCluster, the marker position may be different than the position in the data!\n        const dataLatLng = L.latLng(data.lat, data.lon);\n        const distance = dataLatLng.distanceTo(currentLatLng);\n        const bearing = getBearing(currentLatLng, dataLatLng);\n\n        const popupContent = preparePopupContent(data, '', distance, bearing);\n        popup.setContent(popupContent);\n    }\n    // TODO: update also waypoint info?\n}\n\nfunction locationHandleError(error: GeolocationPositionError) {\n    switch (error.code) {\n        case error.PERMISSION_DENIED:\n            console.error(\"User denied the request for Geolocation.\");\n            break;\n        case error.POSITION_UNAVAILABLE:\n            console.error(\"Location information is unavailable.\");\n            break;\n        case error.TIMEOUT:\n            console.error(\"The request to get user location timed out.\");\n            break;\n        default:\n            console.error(\"An unknown error occurred.\");\n            break;\n    }\n}\n\nlet locationWatchId: number;\nconst locationMarker = L.marker([0, 0], { icon: getIcon('Location') });\nconst locationPopup = L.popup();\n\nfunction onShowLocationInputChange(event: Event): void {\n    if (!(\"geolocation\" in navigator)) {\n        console.warn(\"Geolocation is not supported by this browser.\");\n        return\n    }\n\n    const showLocationInput = event.target as HTMLInputElement;\n    if (showLocationInput.checked) {\n        locationWatchId = navigator.geolocation.watchPosition(\n            (position) => locationShowPosition(position),\n            locationHandleError,\n            { enableHighAccuracy: true }\n        );\n    } else {\n        navigator.geolocation.clearWatch(locationWatchId);\n        locationWatchId = 0;\n        locationMarker.remove();\n        locationMarker.setLatLng([0, 0]);\n        if (popup.isOpen()) { // remove distance from popup...\n            const marker = getMarkerFromPopup(popup);\n            const data = waypointDataMap[marker.waypointName];\n            const popupContent = preparePopupContent(data, '', -1, -1); // no distance and bearing\n            popup.setContent(popupContent);\n        }\n    }\n}\n\n// *** end location service\n\nfunction addItem(key: string, input: string): void {\n    input = input.replace(/^\\n/, \"\").replace(/\\n$/, \"\"); // remove preceding and trailing newlines\n\n    if (!key) { // maybe \"\"\n        console.warn(\"addItem: no key!\");\n        key = \"unknown\";\n    }\n\n    const fileInput = document.getElementById('fileInput') as HTMLInputElement;\n\n    // see also: https://pqina.nl/blog/set-value-to-file-input/\n    const type = key.endsWith('.zip') ? 'application/zip' : 'text/plain';\n    //key.endsWith('.gpx') ? 'application/gpx+xml' : 'text/plain';\n    const myFile = new File([input], key, {\n        type, //'text/plain',\n        lastModified: Date.now()\n    });\n\n    const dataTransfer = new DataTransfer();\n    dataTransfer.items.add(myFile);\n    fileInput.files = dataTransfer.files;\n    fileInput.dispatchEvent(new Event(\"change\"));\n};\n\nasync function loadScriptOrStyle(script: HTMLScriptElement | HTMLLinkElement): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const onScriptLoad = function (event: Event) {\n            const type = event.type; // \"load\" or \"error\"\n            const node = event.currentTarget as HTMLScriptElement | HTMLLinkElement;\n            const key = node.getAttribute(\"data-key\") as string;\n\n            node.removeEventListener(\"load\", onScriptLoad, false);\n            node.removeEventListener(\"error\", onScriptLoad, false);\n\n            if (type === \"load\") {\n                resolve(key);\n            } else {\n                reject(new Error(`Loading failed for ${key}`));\n            }\n        };\n        script.addEventListener(\"load\", onScriptLoad, false);\n        script.addEventListener(\"error\", onScriptLoad, false);\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n}\n\nasync function loadScript(url: string, key: string): Promise<string> {\n    const script = document.createElement(\"script\");\n\n    script.type = \"text/javascript\";\n    script.async = true;\n    script.src = url;\n\n    script.setAttribute(\"data-key\", key);\n\n    return loadScriptOrStyle(script);\n}\n\n// *** start args\n\nfunction fnDecodeUri(s: string): string {\n    let decoded = \"\";\n\n    try {\n        decoded = decodeURIComponent(s.replace(/\\+/g, \" \"));\n    } catch (e) {\n        if (e instanceof Error) {\n            e.message += \": \" + s;\n        }\n        console.error(e);\n    }\n    return decoded;\n}\n\nfunction parseUri(config: Record<string, ConfigEntryType>): string[] {\n    const urlQuery = window.location.search.substring(1);\n    const rSearch = /([^&=]+)=?([^&]*)/g;\n    const args: string[] = [];\n    let match: RegExpExecArray | null;\n\n    while ((match = rSearch.exec(urlQuery)) !== null) {\n        const name = fnDecodeUri(match[1]);\n        const value = fnDecodeUri(match[2]);\n\n        if (value !== null && config[name] !== undefined) {\n            args.push(name + \"=\" + value);\n        }\n    }\n    return args;\n}\n\nfunction parseArgs(args: string[], config: Record<string, ConfigEntryType>): Record<string, ConfigEntryType> {\n    for (const arg of args) {\n        const [name, ...valueParts] = arg.split(\"=\");\n        const nameType = typeof config[name];\n\n        let value: ConfigEntryType = valueParts.join(\"=\");\n        if (value !== undefined) {\n            if (nameType === \"boolean\") {\n                value = value === \"true\";\n            } else if (nameType === \"number\") {\n                value = Number(value);\n            }\n            config[name] = value;\n        }\n    }\n    return config;\n}\n\nfunction debugRedirectConsoleToWaypointInfo() {\n    const waypointInfo = document.getElementById('waypointInfo') as HTMLDivElement;\n    const colors: Record<string, string> = {\n        error: 'red',\n        warn: 'orange',\n        log: 'gray',\n        debug: 'blue'\n    };\n\n    (['error', 'warn', 'log', 'debug'] as const).forEach(method => {\n        const orig = console[method];\n        console[method] = (...args: unknown[]) => {\n            orig(...args);\n            waypointInfo.innerHTML += `<span style=\"color:${colors[method]}\">${args.join(' ')}</span><br>`;\n        };\n    });\n    console.log(\"console messages will be redirected.\");\n}\n\n// *** end args\n\nfunction main(): void {\n    const args = parseUri(config);\n    parseArgs(args, config);\n\n    if (config.debug >= 10) {\n        debugRedirectConsoleToWaypointInfo();\n    }\n    \n    map.setView([0, 0], 2);\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        attribution: ' OpenStreetMap'\n    }).addTo(map);\n\n    waypointGroup.on('click', onWaypointGroupClick);\n    waypointGroup.bindPopup(popup);\n\n    solverGroup.on('click', onSolverGroupClick);\n    solverGroup.bindPopup(solverPopup);\n\n    const fileInput = document.getElementById('fileInput') as HTMLInputElement;\n    fileInput.addEventListener('change', (e: Event) => void onFileInputChange(e));\n\n    const mapElement = document.getElementById('map') as HTMLDivElement;\n    mapElement.addEventListener(\"dragover\", onMapDragover, false);\n    mapElement.addEventListener(\"drop\", (ev: Event) => {\n        ev.stopPropagation();\n        ev.preventDefault(); // required for FireFox\n        void onFileInputChange(ev);\n        fileInput.style.color = 'lightgrey'; // outdated\n    }, false); // onMapDrop\n\n    const waypointSearch = document.getElementById('waypointSearch') as HTMLInputElement;\n    waypointSearch.addEventListener('input', debounce((e) => {\n        const value = (e.target as HTMLInputElement).value;\n        filterWaypoints(value);\n    }, 400));\n\n    if (config.search) {\n        waypointSearch.value = config.search;\n    }\n\n    const waypointSearchClear = document.getElementById('waypointSearchClear') as HTMLButtonElement;\n    waypointSearchClear.addEventListener('click', () => {\n        waypointSearch.value = '';\n        filterWaypoints(waypointSearch.value);\n    });\n\n    const showLocationInput = document.getElementById('showLocationInput') as HTMLInputElement;\n    showLocationInput.addEventListener('change', onShowLocationInputChange);\n\n    locationMarker.bindPopup(locationPopup);\n\n    window.GPXmap = {\n        addItem: (key: string, input: string) => {\n            addItem(key, input);\n        }\n    };\n\n    const editButton = document.getElementById('editButton') as HTMLButtonElement;\n    editButton.addEventListener('click', onEditButtonClick);\n\n    const saveButton = document.getElementById('saveButton') as HTMLButtonElement;\n    saveButton.addEventListener('click', onSaveButtonClick);\n\n    const cancelButton = document.getElementById('cancelButton') as HTMLButtonElement;\n    cancelButton.addEventListener('click', onCancelButtonClick);\n\n    polylineGroup.addTo(map);\n\n    asyncDelay(() => {\n        if (config.file) {\n            const scriptName = config.file;\n            const key = config.file;\n            loadScript(scriptName, key).catch((e) => { console.error(e) });\n        } else {\n            loadWaypointsFromLocalStorage();\n            const waypointSearch = document.getElementById('waypointSearch') as HTMLInputElement;\n            filterWaypoints(waypointSearch.value);\n        }\n    }, 10);\n}\n\nmain();\n"],"names":["global","factory","exports","this","MarkerClusterGroup","options","animate","layer","visibleLayer","currentZoom","layersArray","skipLayerAddEvent","fg","npg","chunked","chunkInterval","chunkProgress","offset","originalArray","started","process","start","elapsed","markers","otherMarker","needsClustering","i","m","l","layersArray2","l2","marker","bounds","method","context","needsRemoving","thisNeedsRemoving","j","layers","id","result","anArray","callback","map","showMarker","vMarker","obj","z","gridUnclustered","minZoom","e","isPopupOpen","from","to","dragStart","removeFromDistanceGrid","dontUpdateMap","gridClusters","cluster","el","oel","type","data","propagate","childCount","c","spiderfyOnMaxZoom","showCoverageOnHover","zoomToBoundsOnClick","spiderfyOnEveryZoom","bottomCluster","newBounds","maxZoom","radius","radiusFn","zoom","markerPoint","closest","parent","newCluster","lastParent","fn","mapZoom","maxLat","group","output","icon","previousZoomLevel","newZoomLevel","startPos","n","me","MarkerCluster","a","b","storageArray","ignoreDraggedMarker","fitBoundsOptions","childClusters","boundsZoom","newClusters","new1","isNotificationFromChild","child","latSum","lngSum","totalCount","childLatLng","center","cm","mapMinZoom","zoomLevel","nm","k","previousBounds","exceptBounds","boundsToApplyTo","zoomLevelToStart","zoomLevelToStop","runAtEveryLevel","runAtBottomLevel","backup","cellSize","point","x","y","grid","row","cell","stamp","len","removed","dist","objectPoint","closestDistSq","coord","p","p2","dx","dy","cpt","bl","vY","vX","baseLine","latLngs","maxD","maxPt","newPoints","pt","d","convexHullBaseLines","t","minLat","maxLng","minLng","maxLatPt","minLatPt","maxLngPt","minLngPt","minPt","ch","childMarkers","points","positions","zoomDetails","count","centerPt","circumference","legLength","angleStep","res","angle","spiderfyDistanceMultiplier","separation","lengthFactor","legOptions","leg","newPos","thisLayerLatLng","thisLayerPos","svg","finalLegOpacity","legPath","nonAnimatable","stillThereChildCount","directlyRefreshClusters","Utils","s","iLen","sFillChar","str","LatLng","lat","lng","deg","rad","clone","comment","format","error","phi1","lambda1","phi2","lambda2","deltaPhi","deltaLambda","theta","distance","bearing","delta","sinPhi1","cosPhi1","sinDelta","cosDelta","sinTheta","cosTheta","sinPhi2","p1","bearing1","bearing2","theta13","theta23","deltaphi","deltalambda","delta12","cosThetaa","cosThetab","thetaa","thetab","theta12","theta21","alpha1","alpha2","alpha3","delta13","phi3","deltalambda13","lambda3","sFormat","dmm2position","aParts","dms2position","dd2position","iCommentIndex","bParseOk","digits","sValue","sComment","position2dmm","position","latNS","lngEW","latdeg","latmin","lngdeg","lngmin","position2dms","latsec","lngsec","position2dd","functionList","commandList","keywordsMap","acc","keyword","toRadians","toDegrees","zFormat","length","numFormat","aFormat","regExpEscape","ScriptParser","message","value","pos","input","isComment","isOperator","isDigit","isWhiteSpace","isQuotes","isNotQuotes","isApostrophe","isNotApostrophe","isIdentifier","isFormatter","isNotFormatter","isNotNewLine","aTokens","sToken","sChar","iStartPos","iIndex","advance","advanceWhile","sToken2","advanceWhileEscape","addToken","iPos","op","nextChar","numToken","tokens","symbols","index","parseTree","fnNode","node","symbol","nud","lbp","led","sym","interpretToken","token","expression","rbp","left","infix","prefix","createFunctionCall","parseIndex","args","generateKeywordSymbols","key","isInIfCondition","condition","commands","variableAccess","functions","that","operators","mFunctions","checkArgs","name","aArgs","oFunction","optionalArgs","iMin","fnAdaptFunctionName","sName","fnAdaptVariableName","parseNode","results","cmd","aNodeArgs","w1","w2","pos1","pos2","angle1","angle2","pos3","err","s2","sOut","aSearch","sStr","iSum","oPosition1","oPosition2","sourceMap","destinatonMap","rSearch","mode","search","replace","escaped","pattern","iNumber","ZipCrypto","crcTable","crc","keys","password","temp","decrypted","cdfh","decryptedHeader","checkByte","out","ZipConstants","textDecoderDecodePolyfill","chunkLen","nums","ZipFile","force","currentData","eocdPos","entryTable","eocd","entries","dostime","lfhExtrafieldLength","codes","lens2","offs","lens","lenCode","distCode","compressedSize","finalSize","startLens","lExt","dists","dExt","dynamicTableOrder","bufEnd","outBuf","inCnt","outCnt","bitCnt","bitBuf","fnBits","need","fnDecode","code","first","fnInflateStored","fnConstructDynamicHuffman","nLen","nDist","nCode","err1","err2","fnInflateHuffmann","last","isEncrypted","fileData","lfhSignature","config","waypointDataMap","L","waypointGroup","popup","solverGroup","solverPopup","markerPool","asyncDelay","timeout","deleteAllItems","items","debounce","delay","timeoutId","setButtonDisabled","disabled","element","getPooledMarker","lon","clearMarkersFromGroup","iconColors","iconCache","getIcon","cacheType","color","size","renderMarkers","markersData","keepView","polylineGroup","privSetPolyline","path","aLayers","mPolylineOptions","setPolyline","solverMarkersData","aPath","oItem","oPosition","solverDataMap","renderSolverMarkers","filterWaypoints","query","q","waypointData","waypointCount","filtered","insertNewlineAtLastMatch","find","keepMatch","lastMatch","matchLen","add","latAbs","lonAbs","lonEW","latDeg","latMin","lonDeg","lonMin","directions","getDirection","formatDistance","getBearing","toRad","toDeg","lat1","lat2","dLon","brng","preparePopupContent","solverCodeInHtml","moreInfo","selectedMarker","searchPoint","threshold","mainData","mainLatLng","wpPopupContent","dmm","desc","distanceStr","getWaypointFromLocalStorage","storedData","getSolverCode","putWaypointAndSolverIntoLocalStorage","waypoint","removeKeyFromLocalStorage","loadWaypointsFromLocalStorage","getSolverCodeInHtml","solverCode","prepareInfoContent","cacheInfo","getWaypointInfoHtml","setWaypointInfoHtml","html","waypointInfo","parseSolverCode","variables","name2","errorMsg","prepareSolverMarkersData","solverPoints","entry","latLon","selectMarker","currentLatLng","locationMarker","isInitialLocation","dataLatLng","infoContent","popupContent","text","selectSolverMarker","clearSolverLayers","onWaypointGroupClick","onSolverGroupClick","processZipFile","uint8Array","zipName","messages","zip","zipDirectory","binaryData","messages2","utf8Text","parseGpxFile","parser","xml","errorNode","overwritten","wpts","wpt","cacheElem","archived","available","cacheName","container","longDesc","hints","match","overwrittenStr","onFileInputChange","event","infoHtml","startTime","dataTransfer","files","inputElement","file","arrayBuffer","fileName","addItem","waypointSearch","endTime","onEditButtonClick","onSaveButtonClick","solverCodeEdited","onCancelButtonClick","onMapDragover","ev","getMarkerFromPopup","locationShowPosition","latitude","longitude","oldLocation","locationHandleError","locationWatchId","locationPopup","onShowLocationInputChange","fileInput","myFile","loadScriptOrStyle","script","resolve","reject","onScriptLoad","loadScript","url","fnDecodeUri","decoded","parseUri","urlQuery","parseArgs","arg","valueParts","nameType","debugRedirectConsoleToWaypointInfo","colors","orig","main","mapElement","scriptName"],"mappings":"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","x_google_ignoreList":[0]}